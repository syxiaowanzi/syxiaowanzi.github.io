<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis使用]]></title>
    <url>%2F2019%2F01%2F20%2Fredis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境jdk1.8、redis数据库commons-logging-1.0.4.jarcommons-pool2-2.6.0.jarjedis-2.9.0.jarlog4j-1.2.16.jar 代码 1.com.redis.RedisKeys.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.redis;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.apache.log4j.Logger;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * log4j(commons-logging/log4j) * redis(jedis/commons-pool2) * @author wangming * */public class RedisUtil &#123; private static JedisPool pool=null; //最大连接数 private static int max_active=50; //最大空闲数 private static int max_idle=40; //等待时间 private static long max_waitmillis=3000; //redis主机地址 private static String host; //redis端口 private static int port; //redis用户密码 private static String password; //过期时间 private static int expireTime = 2*60*60*1000; static Logger logger = Logger.getLogger(RedisUtil.class); static&#123; try &#123; //获取配置文件内容 InputStream in = RedisUtil.class.getResourceAsStream(&quot;redis.properties&quot;); Properties prop = new Properties(); prop.load(in); RedisUtil.max_active = Integer.parseInt(prop.getProperty(&quot;max_active&quot;)); RedisUtil.max_idle = Integer.parseInt(prop.getProperty(&quot;max_idle&quot;)); RedisUtil.max_waitmillis = Long.parseLong(prop.getProperty(&quot;max_waitmillis&quot;).toString()); RedisUtil.host = prop.getProperty(&quot;host&quot;); RedisUtil.port = Integer.parseInt(prop.getProperty(&quot;port&quot;)); RedisUtil.password = prop.getProperty(&quot;password&quot;); //初始化连接池 RedisUtil.pool = initPool(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*** * 初始化连接池 * @return */ private static JedisPool initPool()&#123; JedisPool result = null; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(max_idle); config.setMaxWaitMillis(max_waitmillis); config.setTestOnBorrow(true); if(RedisUtil.password==null||&quot;&quot;.equals(RedisUtil.password))&#123; result = new JedisPool(config,host,port); &#125;else&#123; result = new JedisPool(config,host,port,3000,RedisUtil.password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 向redis添加String，成功返回0，失败返回1 * @param String */ public static int set(String key,String value)&#123; if(value==null || key==null)&#123; logger.debug(&quot;redis存储对象时传入参数为空&quot;); return 1; &#125; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); jedis.set(key, value); &#125;catch(Exception e)&#123; logger.debug(&quot;对象存储redis失败&quot;); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /** * redis数据库查询 */ public static String get(String key)&#123; if(key==null)&#123; logger.debug(&quot;redis查询方法，传入参数为空&quot;); return null; &#125; String result=&quot;&quot;; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); result = jedis.get(key); &#125;catch(Exception e)&#123; logger.debug(&quot;redis查询方法执行失败&quot;+e); &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return result; &#125; /** * 封装jedis的hset方法解释如下 * @param key RedisKeys.TEST+字符串 eg RedisKeys.TEST+123456 * @param field 实体类的类名 * @param value 对应分项内容的json串 * @return */ public static long hset(String key,String field,String value)&#123; long result =0; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hset(key, field, value); //设置两小时过期 jedis.expire(key,expireTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 封装redis的hget方法,，解释如下 * @param key RedisKeys.TEST+字符串 eg RedisKeys.TEST+123456 * @param field 对应实体类的类名 * @return result 对应分项内容的json串 */ public static String hget(String key,String field)&#123; String result =null; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hget(key, field); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 设置过期时间 * @param value 秒 * @return 成功返回0，失败返回1 */ public static int expire(String key,int value)&#123; if(key==null)&#123; logger.debug(&quot;redis设置失效时间，传入key参数为空&quot;); return 1; &#125; Jedis jedis =null; try&#123; jedis = RedisUtil.getJedis(); jedis.expire(key, value); &#125;catch(Exception e)&#123; logger.debug(&quot;redis设置&quot;+key+&quot;失效时间失败&quot;); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /*** * 获取Jedis实例 * @return Jedis实例 */ public static Jedis getJedis()&#123; Jedis result = null; try &#123; result = RedisUtil.pool.getResource(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /*** * 关闭 Jedis * @param jedis */ public static void closeJedis(Jedis jedis)&#123; if(jedis!=null)&#123; jedis.close(); &#125; &#125; public static void main(String[] args) &#123;// Jedis jedis = getJedis(); String openid = &quot;o5lHPww7MK_ca1-LFLzWUjTRJ7oU&quot;; RedisUtil.set(RedisKeys.TEST+openid, &quot;20180920/1537413108683.jpg|20180920/1537413108633.jpg|&quot;); String str = RedisUtil.get(RedisKeys.TEST+openid); //RedisUtil.expire(RedisKeys.TEST, 10*60*60*1000); System.out.println(str); String[] strs = str.split(&quot;\\|&quot;); System.out.println(strs[0]); /*int i = RedisUtil.expire(RedisKeys.IMAGEACQUISITION, 0); System.out.println(i);*/ &#125;&#125;2.com.redis.RedisKeys.java1234package com.redis;public class RedisKeys &#123; public static final String TEST = &quot;test_&quot;;&#125;3.com.redis下配置文件redis.properties1234567891011max_active=100#\u6700\u5927\u7a7a\u95f2\u6570max_idle=40#\u6700\u5927\u7b49\u5f85\u65f6\u95f4max_waitmillis=3000#redis\u5730\u5740host=127.0.0.1#redis\u7aef\u53e3port=6379#redis\u5bc6\u7801password=xxx4.com.redis下配置文件log4j.properties12345678910# Global logging configurationlog4j.rootLogger=INFO, stdout# My logging configuration...log4j.logger.com.geong=INFO## Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>redis redis工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加上评论系统-Valine]]></title>
    <url>%2F2019%2F01%2F20%2FHexo%E5%8A%A0%E4%B8%8A%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-Valine%2F</url>
    <content type="text"><![CDATA[环境hexo v3.8.0 、NexT.Pisces v6.7.0、leancloud 步骤leadcloud官网注册账号登陆leadcloud官网 注册 创建应用 应用名称可以自定义 获取appid与appkey创建之后进入应用-设置-应用key 进入博客next主题配置文件中修改搜素valine找到一下内容，修改enable，粘贴id、key，重新打包文件valine:&nbsp;&nbsp;&nbsp;&nbsp;enable: true&nbsp;&nbsp;&nbsp;&nbsp;appid:&nbsp;&nbsp;&nbsp;&nbsp;appkey:&nbsp;&nbsp;&nbsp;&nbsp;notify: false&nbsp;&nbsp;&nbsp;&nbsp;verify: false&nbsp;&nbsp;&nbsp;&nbsp;placeholder: 说点什么…&nbsp;&nbsp;&nbsp;&nbsp;avatar: mm&nbsp;&nbsp;&nbsp;&nbsp;guest_info: nick,mail,link&nbsp;&nbsp;&nbsp;&nbsp;pageSize: 10&nbsp;&nbsp;&nbsp;&nbsp;visitor: false&nbsp;&nbsp;&nbsp;&nbsp;comment_count: true 刷新页面评论测试假如第一次不成功，等两分钟后重新测试 假如某一页面不想加评论在顶部添加comments: false，同样适用与标签与分类 参考地址https://blog.csdn.net/blue_zy/article/details/79071414]]></content>
      <categories>
        <category>hexo-next主题优化</category>
      </categories>
      <tags>
        <tag>hexo添加评论 hexo next主题添加评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet生成图片验证码]]></title>
    <url>%2F2019%2F01%2F19%2Fservlet%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[环境eclipse(2018-12 (4.10.0)),jdk1.8.0_191,tomcat7.0.62代码1.SafeCodeUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.common.utils.safecode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** 生成指定大小的图片验证码，返回 * 并将图片验证码存入session中 * session对象imageCode * @author admin */public class SafeCodeUtil &#123; public static final String RANDOMCODEKEY = &quot;imageCode&quot;;//放到session中的key private Random random = new Random(); //private String randString = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//随机产生的字符串 private String randString = &quot;23456789ABCDEFGHJKLMNPRSTWXY&quot;;//随机产生的字符串 private int width = 73;//图片宽 private int height = 28;//图片高 private int lineSize = 30;//干扰线数量 private int stringNum = 4;//随机产生字符数量 /* * 获得字体 */ private Font getFont()&#123; return new Font(&quot;Fixedsys&quot;,Font.CENTER_BASELINE,18); &#125; /* * 获得颜色 */ private Color getRandColor(int fc,int bc)&#123; if(fc &gt; 255) &#123; fc = 255; &#125; if(bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc-fc-16); int g = fc + random.nextInt(bc-fc-14); int b = fc + random.nextInt(bc-fc-18); return new Color(r,g,b); &#125; /** * 生成随机图片 */ public void getRandcode(HttpServletRequest request, HttpServletResponse response) &#123; HttpSession session = request.getSession(); //BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR); Graphics g = image.getGraphics();//产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作 g.fillRect(0, 0, width, height); g.setFont(new Font(&quot;Times New Roman&quot;,Font.ROMAN_BASELINE,18)); g.setColor(getRandColor(110, 133)); //绘制干扰线 for(int i=0;i&lt;=lineSize;i++)&#123; drowLine(g); &#125; //绘制随机字符 String randomString = &quot;&quot;; for(int i=1;i&lt;=stringNum;i++)&#123; randomString=drowString(g,randomString,i); &#125; session.removeAttribute(RANDOMCODEKEY); session.setAttribute(RANDOMCODEKEY, randomString); g.dispose(); try &#123; ImageIO.write(image, &quot;JPEG&quot;, response.getOutputStream());//将内存中的图片通过流动形式输出到客户端 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /* * 绘制字符串 */ private String drowString(Graphics g,String randomString,int i)&#123; g.setFont(getFont()); g.setColor(new Color(random.nextInt(101),random.nextInt(111),random.nextInt(121))); String rand = String.valueOf(getRandomString(random.nextInt(randString.length()))); randomString +=rand; g.translate(random.nextInt(3), random.nextInt(3)); g.drawString(rand, 13*i, 16); return randomString; &#125; /* * 绘制干扰线 */ private void drowLine(Graphics g)&#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(13); int yl = random.nextInt(15); g.drawLine(x, y, x+xl, y+yl); &#125; /* * 获取随机的字符 */ public String getRandomString(int num)&#123; return String.valueOf(randString.charAt(num)); &#125;&#125;2.SafeCode.java123456789101112131415161718192021222324package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/**生成验证码**/public class SafeCode extends HttpServlet &#123; private static final long SERIAL_VERSION_UID = 1L; @Override public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;image/jpeg&quot;);// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;3.GenerateImageCode.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.common.utils.safecode.SafeCodeUtil;/** * @author wangming * 生成随机验证码 * Servlet implementation class GenerateImageCode */@WebServlet(&quot;/GenerateImageCode&quot;)public class GenerateImageCode extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public GenerateImageCode() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doPost(request, response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType(&quot;image/jpeg&quot;);// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;4.web.xml内webapps标签添加如下代码12345678&lt;servlet&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;servlet-class&gt;com.common.utils.safecode.GenerateImageCode&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;url-pattern&gt;/SafeCode&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;访问路径与结果http://localhost:8888/servletImgVerificationr/SafeCode，结果如下：克隆地址:https://github.com/syxiaowanzi/servlet-utils.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>验证码 图片验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署与上传github]]></title>
    <url>%2F2019%2F01%2F19%2Fhexo%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%B8%8A%E4%BC%A0github%2F</url>
    <content type="text"><![CDATA[环境winds10,github账户 搭建nodejs安装（我的版本v.10.15.0） 安装git与git客户端安装hexo,可以随便选择文件夹npm install -g hexo-cli hexo初始化与启动hexo init //初始化hexo generate //生成静态页面可以简写成 hexo ghexo server //启动可以简写成 hexo s 默认端口4000 访问本地即可看到一个helloworldhttp://localhost:4000 安装部署到github插件依赖，在站点根目录执行npm install hexo-deployer-git –save github上创建空博客创建新的仓库这里注意例如图中syxiaowanzi.github.io中syxiaowanzi必须是拥有者https://syxiaowanzi.github.io 本地hexo关联github上的博客hexo目录下_config.yml文件最下面添加 deploy: &nbsp;&nbsp;&nbsp;&nbsp;type: git &nbsp;&nbsp;&nbsp;&nbsp;repo: https://github.com/syxiaowanzi/syxiaowanzi.github.io.git &nbsp;&nbsp;&nbsp;&nbsp;branch: master 生成rsakeyssh-keygen -t rsa -C &quot;your github email” 默认会在C:\Users\yourPC.rsa生成连个文件id_rsa.pub与id_rsa 打开id_rsa.pub文件复制内容放到我们当前博客的仓库中 本地上传githubhexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 访问你的github博客即可看到helloworld优化博客我们可以选择多种优化主题，优化菜单等参考链接：https://blog.csdn.net/qq_32454537/article/details/79482896https://www.jianshu.com/p/efbeddc5eb19https://www.jianshu.com/p/56d99a3049a5]]></content>
      <categories>
        <category>hexo部署</category>
      </categories>
      <tags>
        <tag>hexo部署 hexo上传github</tag>
      </tags>
  </entry>
</search>
