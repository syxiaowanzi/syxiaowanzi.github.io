<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java设计模式]]></title>
    <url>%2F2019%2F01%2F22%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[分为三类创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式，建造者模式，原型模式。结构型模式（7种）：适配器模式、装饰器模式、代理模式，外观模式、桥接模式、组合模式、享元模式。行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 遵循的原则 1、开闭原则（Open Close Principle） 对扩展开放，对修改关闭。2、里氏代换原则（Liskov Substitution Principle） 只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，对接口编程，依赖于抽象而不依赖于具体。4、接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口来降低耦合度。5、迪米特法则（最少知道原则）（Demeter Principle） 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。6、合成复用原则（Composite Reuse Principle） 原则是尽量使用合成/聚合的方式，而不是使用继承。继承实际上破坏了类的封装性，超类的方法可能会被子类修改。 几种常用的设计模式单例模式单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的一个类只有一个实例。即一个类只有一个对象实例。在Spring中创建的Bean实例默认都是单例模式存在的。1234567891011121314151617181920package com.design.model.singleton;/** * 单利模式懒汉式 * 全局的单例实例在第一次被使用时构建 * @author ming */public class Sluggard &#123; private Sluggard() &#123;&#125; private static volatile Sluggard singleton = null; public static Sluggard getInstance() &#123; synchronized(Sluggard.class) &#123; if(singleton==null) &#123; singleton = new Sluggard(); &#125; &#125; return singleton; &#125;&#125;12345678910111213141516package com.design.model.singleton;/** * 单利模式饿汉式 * 全局的单例实例在类装载时构建 * @author ming */public class Hunger &#123; private Hunger() &#123;&#125; private static final Hunger singleton = new Hunger(); public static Hunger getInstance()&#123; return singleton ; &#125; &#125; 工厂模式静态工厂模式-工厂方法常用的工厂模式是静态工厂，利用static方法，作为一种类似于常见的工具类Utils等辅助效果，一般情况下工厂类不需要实例化。12345package com.design.model.staticfactory;public interface Wine &#123; void degree();&#125;12345678910package com.design.model.staticfactory;public class A implements Wine&#123; @Override public void degree() &#123; System.out.println("42度白酒"); &#125; &#125;12345678910package com.design.model.staticfactory;public class B implements Wine&#123; @Override public void degree() &#123; System.out.println("48度白酒"); &#125; &#125;1234567891011121314151617181920212223242526package com.design.model.staticfactory;public class StaticFactory &#123; private StaticFactory() &#123;&#125; public static Wine getA()&#123; return new A(); &#125; public static Wine getB()&#123; return new B(); &#125; static class Client&#123; //客户端代码只需要将相应的参数传入即可得到对象 //用户不需要了解工厂类内部的逻辑。 public Wine get(String name)&#123; Wine wine = null ; if ( name.equals("A")) &#123; wine = StaticFactory.getA(); &#125;else if ( name.equals("B"))&#123; wine = StaticFactory.getB(); &#125; return wine; &#125; &#125; public static void main(String[] args) &#123; Client cli = new Client(); Wine wine = cli.get("A"); wine.degree(); &#125;&#125; 抽象工厂模式一个基础接口定义了功能，每个实现接口的子类就是产品，然后定义一个工厂接口，实现了工厂接口的就是工厂，这时候，接口编程的优点就出现了，我们可以新增产品类（只需要实现产品接口），只需要同时新增一个工厂类，客户端就可以轻松调用新产品的代码。抽象工厂的灵活性就体现在这里，无需改动原有的代码，毕竟对于客户端来说，静态工厂模式在不改动StaticFactory类的代码时无法新增产品，如果采用了抽象工厂模式，就可以轻松的新增拓展类。简单示例：1.抽象产品接口：定义产品的接口，公共的暴露方法。便于实际的产品类实现。2.具体的产品类:包含实际产品的类的逻辑处理。3.抽象工厂接口：定义产生系列对象的接口。4.具体的工厂实现：实现抽象的接口工厂，返回具体的产品类的实现。12345678package com.design.model.abstractfactory;/** * 抽象产品角色 吃早餐接口 * @author ming */public interface IBreakFast &#123; void eat();&#125;1234567891011package com.design.model.abstractfactory;/** * 具体产品角色，喝牛奶 * @author ming */public class Milk implements IBreakFast &#123; @Override public void eat() &#123; System.out.println("喝牛奶！"); &#125;&#125;1234567891011package com.design.model.abstractfactory;/** * 具体产品角色，吃橘子 * @author ming */public class Orange implements IBreakFast &#123; @Override public void eat() &#123; System.out.println("吃橘子!"); &#125;&#125;12345678package com.design.model.abstractfactory;/** * 定义好抽象的工厂接口，一系列的获取实例的接口方法 * @author ming */public interface IAbstractFactory &#123; IBreakFast getBreakFast();&#125;1234567891011121314package com.design.model.abstractfactory;/** * 定义具体的工厂生产类，具体的产品实例返回 * @author ming */public class HighPersonFactory implements IAbstractFactory &#123; @Override public IBreakFast getBreakFast() &#123; // TODO Auto-generated method stub return new Milk(); &#125;&#125;12345678910111213package com.design.model.abstractfactory;/** * 定义具体的工厂生产类，具体的产品实例返回 * @author ming */public class LowPersonFactory implements IAbstractFactory &#123; @Override public IBreakFast getBreakFast() &#123; return new Orange(); &#125;&#125;12345678910111213141516package com.design.model.abstractfactory;/** * 测试 * @author ming */public class AbstractFactoryTest &#123; public static void main(String[] args) &#123; IAbstractFactory factory = new HighPersonFactory(); IBreakFast breakFast = factory.getBreakFast(); breakFast.eat(); IAbstractFactory factory2 = new LowPersonFactory(); IBreakFast breakFast2 = factory2.getBreakFast(); breakFast2.eat(); &#125;&#125;这样使用过程城中，只要注入抽象的工厂接口，具体的产品的产生，会在实际的子类工厂类中产生，也可以随意的添加和修改实际子类工厂类，而不需要改变既有的代码设计。 装饰模式（Decorator）给一类对象增加新的功能，装饰类对装饰对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能12345678package com.design.model.decorator;/** * 定义接口 * @author ming */public interface IRunner &#123; public void run();&#125;1234567891011121314package com.design.model.decorator;/** * 接口具体实现 * @author ming * */public class Runner implements IRunner &#123; @Override public void run() &#123; System.out.println("运动员在跑步..."); &#125;&#125;1234567891011121314151617181920212223242526package com.design.model.decorator;/** * 装饰类 * @author ming */public class RunnerWithJet implements IRunner &#123; private IRunner runner; public RunnerWithJet(IRunner runner) &#123; this.runner = runner; &#125; @Override public void run() &#123; System.out.println("给运动员屁股后加一个推进装置..."); runner.run(); &#125; public static void main(String[] args) &#123; IRunner runner = new Runner(); IRunner superRunner = new RunnerWithJet(runner); System.out.println("有人请求加强版运动员跑步..."); superRunner.run(); &#125;&#125; 代理模式（Proxy）客户端通过代理类访问，代理类实现具体的实现细节，客户只需要使用代理类即可实现操作。这种模式可以对旧功能进行代理，用一个代理类调用原有的方法，且对产生的结果进行控制。12345678package com.design.model.proxy;/** * 定义接口 * @author ming */public interface IRunner &#123; public void run();&#125;1234567891011121314package com.design.model.proxy;/** * 接口具体实现 * @author ming * */public class Runner implements IRunner &#123; @Override public void run() &#123; System.out.println("运动员在跑步..."); &#125;&#125;123456789101112131415161718192021222324252627282930package com.design.model.proxy;public class RunnerAgent implements IRunner &#123; private IRunner runner; private boolean flag; public RunnerAgent(IRunner runner,boolean flag) &#123; this.runner = runner; this.flag = flag; &#125; @Override public void run() &#123; if(flag) &#123; System.out.println("代理人安排运动员跑步..."); runner.run(); &#125;else &#123; System.out.println("代理人有事情，不安排运动员跑步了..."); &#125; &#125; public static void main(String[] args) &#123; IRunner runner = new Runner(); IRunner agent = new RunnerAgent(runner,true); System.out.println("有人请求代理人让运动员跑步..."); agent.run(); &#125;&#125; 适配器模式（Adapter）将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。适配器模式的别名为包装器(Wrapper)模式，它既可以作为类结构型模式，也可以作为对象结构型模式。在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。 类适配器模式原理：通过继承来实现适配器功能。当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后再继承接口B的实现类BB，这样我们可以在适配器P中访问接口B的方法了，这时我们在适配器P中的接口A方法中直接引用BB中的合适方法，这样就完成了一个简单的类适配器。123public interface Ps2 &#123; void isPs2();&#125;123public interface Usb &#123; void isUsb();&#125;12345678public class Usber implements Usb &#123; @Override public void isUsb() &#123; System.out.println("USB口"); &#125;&#125;12345678public class Adapter extends Usber implements Ps2 &#123; @Override public void isPs2() &#123; isUsb(); &#125;&#125;123456public class Clienter &#123; public static void main(String[] args) &#123; Ps2 p = new Adapter(); p.isPs2(); &#125;&#125; 对象适配器模式原理：通过组合来实现适配器功能。当我们要访问的接口A中没有我们想要的方法 ，却在另一个接口B中发现了合适的方法，我们又不能改变访问接口A，在这种情况下，我们可以定义一个适配器p来进行中转，这个适配器p要实现我们访问的接口A，这样我们就能继续访问当前接口A中的方法（虽然它目前不是我们的菜），然后在适配器P中定义私有变量C（对象）（B接口指向变量名），再定义一个带参数的构造器用来为对象C赋值，再在A接口的方法实现中使用对象C调用其来源于B接口的方法。123public interface Ps2 &#123; void isPs2();&#125;123public interface Usb &#123; void isUsb();&#125;12345678public class Usber implements Usb &#123; @Override public void isUsb() &#123; System.out.println("USB口"); &#125;&#125;123456789101112public class Adapter implements Ps2 &#123; private Usb usb; public Adapter(Usb usb)&#123; this.usb = usb; &#125; @Override public void isPs2() &#123; usb.isUsb(); &#125;&#125;12345678public class Clienter &#123; public static void main(String[] args) &#123; Ps2 p = new Adapter(new Usber()); p.isPs2(); &#125;&#125; 接口适配器模式原理：通过抽象类来实现适配，这种适配稍别于上面所述的适配。当存在这样一个接口，其中定义了N多的方法，而我们现在却只想使用其中的一个到几个方法，如果我们直接实现接口，那么我们要对所有的方法进行实现，哪怕我们仅仅是对不需要的方法进行置空（只写一对大括号，不做具体方法实现）也会导致这个类变得臃肿，调用也不方便，这时我们可以使用一个抽象类作为中间件，即适配器，用这个抽象类实现接口，而在抽象类中所有的方法都进行置空，那么我们在创建抽象类的继承类，而且重写我们需要使用的那几个方法即可。12345678public interface A &#123; void a(); void b(); void c(); void d(); void e(); void f();&#125;12345678public abstract class Adapter implements A &#123; public void a()&#123;&#125; public void b()&#123;&#125; public void c()&#123;&#125; public void d()&#123;&#125; public void e()&#123;&#125; public void f()&#123;&#125;&#125;12345678public class Ashili extends Adapter &#123; public void a()&#123; System.out.println("实现A方法被调用"); &#125; public void d()&#123; System.out.println("实现d方法被调用"); &#125;&#125;123456789public class Clienter &#123; public static void main(String[] args) &#123; A a = new Ashili(); a.a(); a.d(); &#125;&#125; 建造者模式（Builder）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Builder &#123; static class Student&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; //构建器，利用构建器作为参数来构建Student对象 static class StudentBuilder&#123; String name = null ; int number = -1 ; String sex = null ; int age = -1 ; String school = null ; public StudentBuilder setName(String name) &#123; this.name = name; return this ; &#125; public StudentBuilder setNumber(int number) &#123; this.number = number; return this ; &#125; public StudentBuilder setSex(String sex) &#123; this.sex = sex; return this ; &#125; public StudentBuilder setAge(int age) &#123; this.age = age; return this ; &#125; public StudentBuilder setSchool(String school) &#123; this.school = school; return this ; &#125; public Student build() &#123; return new Student(this); &#125; &#125; public Student(StudentBuilder builder)&#123; this.age = builder.age; this.name = builder.name; this.number = builder.number; this.school = builder.school ; this.sex = builder.sex ; &#125; &#125; public static void main( String[] args )&#123; Student a = new Student.StudentBuilder().setAge(13).setName("LiHua").build(); Student b = new Student.StudentBuilder().setSchool("sc").setSex("Male").setName("ZhangSan").build(); &#125;&#125; 策略模式其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。TreeSet集合就采用了经典的策略模式的思想。策略模式体现了面向对象程序设计中非常重要的两个原则：1.封装变化的概念。2.编程中使用接口，而不是使用的是具体的实现类(面向接口编程)。实现一个加减乘除的功能，如下123456789package com.design.model.strategy;/** * 定义抽象策略角色 * @author ming */public interface Strategy &#123; //定义两个数可以计算 public int calc(int num1,int num2);&#125;12345678910111213package com.design.model.strategy;/** * 定义加法策略 * @author ming */public class AddStrategy implements Strategy &#123; @Override public int calc(int num1, int num2) &#123; return num1+num2; &#125;&#125;12345678910111213package com.design.model.strategy;/** * 定义减法策略 * @author ming */public class SubstractStrategy implements Strategy &#123; @Override public int calc(int num1, int num2) &#123; return num1-num2; &#125;&#125;12345678910111213141516171819202122package com.design.model.strategy;/** * 环境角色 */public class Environment &#123; public Strategy strategy; public Environment(Strategy strategy) &#123; this.strategy = strategy; &#125; public int calulate(int a,int b) &#123; return strategy.calc(a, b); &#125; public static void main(String[] args) &#123; Strategy strategy = new AddStrategy(); Environment environment = new Environment(strategy); System.out.println(environment.calulate(20, 30)); &#125; &#125; 推荐一本让人看了睡觉的好书《java多线程编程（设计模式篇）-黄海文》 参考地址http://www.cnblogs.com/malihe/p/6891920.htmlhttps://www.cnblogs.com/lilin0719/p/5313886.htmlhttps://www.cnblogs.com/luoxn28/p/5535877.htmlhttps://www.cnblogs.com/songyaqi/p/4805820.htmlhttp://baijiahao.baidu.com/s?id=1601547440739500969&amp;wfr=spider&amp;for=pc]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>设计模式 java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java发送邮件]]></title>
    <url>%2F2019%2F01%2F22%2Fjava%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[环境jdk1.8activation.jarjavax.mail-1.6.2.jarlog4j-1.2.12.jarcommons-logging-1.1.1.jar 配置开启服务以qq邮箱为例，开启POP3/SMTP-IMAP/SMTP服务邮箱-设置-账户生成授权码之后一定要记住，代码中会用到 代码com.email.util下EmailUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.email.util;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import org.apache.log4j.Logger;import java.io.File;import java.util.Properties;/** * 封装Email相关的操作 */public final class EmailUtil &#123; private static Logger logger = Logger.getLogger(EmailUtil.class); private Properties properties = new Properties(); /** * Message对象将存储我们实际发送的电子邮件信息， */ private MimeMessage message; /** * Session类代表JavaMail中的一个邮件会话。 */ private Session session; private Transport transport; private String mailHost = ""; private int port = 465; private boolean auth = false; private String sender_username = ""; private String sender_password = ""; /** * 初始化方法 */ public EmailUtil(boolean debug) &#123; this.mailHost = EmailPropertiesUtil.getProperty("mail.smtp.host"); this.port = Integer.valueOf(EmailPropertiesUtil.getProperty("mail.smtp.port")); this.auth = Boolean.parseBoolean(EmailPropertiesUtil.getProperty("mail.smtp.auth")); this.sender_username = EmailPropertiesUtil.getProperty("mail.sender.username"); this.sender_password = EmailPropertiesUtil.getProperty("mail.sender.password"); properties.put("mail.smtp.host", mailHost); properties.put("mail.smtp.auth", auth); properties.put("mail.smtp.port", String.valueOf(port)); properties.put("mail.sender.username", sender_username); properties.put("mail.sender.password", sender_password); properties.put("mail.smtp.socketFactory.class", "javax.net.ssl.SSLSocketFactory"); session = Session.getInstance(properties); session.setDebug(debug);//开启后有调试信息 message = new MimeMessage(session); &#125; /** * 发送邮件 * * @param subject 邮件主题 * @param sendHtml 邮件内容 * @param receiveUser 收件人地址 */ public void doSendHtmlEmail(String subject, String sendHtml, String receiveUser) &#123; try &#123; // 发件人 InternetAddress from = new InternetAddress(sender_username); // 下面这个是设置发送人的Nick name //InternetAddress from = new InternetAddress(MimeUtility.encodeWord("幻影") + " &lt;" + sender_username + "&gt;"); message.setFrom(from); // 收件人 InternetAddress to = new InternetAddress(receiveUser); message.setRecipient(Message.RecipientType.TO, to);//还可以有CC、BCC // 邮件主题 message.setSubject(subject); String content = sendHtml.toString(); // 邮件内容,也可以使纯文本"text/plain" message.setContent(content, "text/html;charset=UTF-8"); // 保存邮件 message.saveChanges(); transport = session.getTransport("smtp"); // smtp验证，就是你用来发邮件的邮箱用户名密码 logger.info("授权码:"+sender_password); transport.connect(mailHost, port, sender_username, sender_password); // 发送 transport.sendMessage(message, message.getAllRecipients()); //System.out.println("send success!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (transport != null) &#123; try &#123; transport.close(); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 发送邮件 * * @param subject 邮件主题 * @param sendHtml 邮件内容 * @param receiveUser 收件人地址 * @param attachment 附件 */ public void doSendHtmlEmail(String subject, String sendHtml, String receiveUser, File attachment) &#123; try &#123; // 发件人 InternetAddress from = new InternetAddress(sender_username); message.setFrom(from); // 收件人 InternetAddress to = new InternetAddress(receiveUser); message.setRecipient(Message.RecipientType.TO, to); // 邮件主题 message.setSubject(subject); // 向multipart对象中添加邮件的各个部分内容，包括文本内容和附件 Multipart multipart = new MimeMultipart(); // 添加邮件正文 BodyPart contentPart = new MimeBodyPart(); contentPart.setContent(sendHtml, "text/html;charset=UTF-8"); multipart.addBodyPart(contentPart); // 添加附件的内容 if (attachment != null) &#123; BodyPart attachmentBodyPart = new MimeBodyPart(); DataSource source = new FileDataSource(attachment); attachmentBodyPart.setDataHandler(new DataHandler(source)); // 网上流传的解决文件名乱码的方法，其实用MimeUtility.encodeWord就可以很方便的搞定 // 这里很重要，通过下面的Base64编码的转换可以保证你的中文附件标题名在发送时不会变成乱码 //sun.misc.BASE64Encoder enc = new sun.misc.BASE64Encoder(); //messageBodyPart.setFileName("=?GBK?B?" + enc.encode(attachment.getName().getBytes()) + "?="); //MimeUtility.encodeWord可以避免文件名乱码 attachmentBodyPart.setFileName(MimeUtility.encodeWord(attachment.getName())); multipart.addBodyPart(attachmentBodyPart); &#125; // 将multipart对象放到message中 message.setContent(multipart); // 保存邮件 message.saveChanges(); transport = session.getTransport("smtp"); // smtp验证，就是你用来发邮件的邮箱用户名密码 transport.connect(mailHost, port, sender_username, sender_password); // 发送 transport.sendMessage(message, message.getAllRecipients()); logger.info("send success!"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (transport != null) &#123; try &#123; transport.close(); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; EmailUtil eu = new EmailUtil(true); eu.doSendHtmlEmail("ceshi", "这是一个测试邮件", "himingwang@126.com"); &#125;&#125; com.email.util下EmailPropertiesUtil.java123456789101112131415161718192021222324252627282930package com.email.util;import java.io.IOException;import java.util.Properties;/** * @author wangming * @version * 读取获取配置文件相关信息 * */public class EmailPropertiesUtil &#123; private static Properties p = System.getProperties(); private static EmailPropertiesUtil propertiesUtil = null; private EmailPropertiesUtil()&#123; try &#123; p.load(EmailPropertiesUtil.class.getResourceAsStream("email.properties")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String getProperty(String key)&#123; if(propertiesUtil == null)&#123; propertiesUtil = new EmailPropertiesUtil(); &#125; return p.getProperty(key); &#125; public static void clear()&#123; p.clear(); &#125;&#125; com.email.util下email.properties12345mail.smtp.host=smtp.qq.commail.smtp.port=465mail.smtp.auth=truemail.sender.username=账户地址mail.sender.password=16位授权码 src下log4j.properties123456log4j.logger.com.opslab.util = ERRORlog4j.rootLogger = ERROR , stdoutlog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern =%d&#123;yyyy-MM-dd HH:mm:ss&#125; %5p [%c:%L] - %m%n 成功结果 git克隆地址https://github.com/syxiaowanzi/send-mail-util.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java发送邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字段校验工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%AD%97%E6%AE%B5%E6%A0%A1%E9%AA%8C%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述判断传入的字符串 是否符合特定的格式（非空 、手机号、验证固定电话、日期、邮箱、身份证号、姓名、验证英文名、邮编、验证出生日期、数字、小数点后两位的数字 、护照、企业姓名、企业证件号、台湾居民来往大陆通行证,港澳同胞回乡证、校验军官证、校验出生证明、校验港澳台居民居住证） 代码FieldValidationUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491package com.common.utils.register;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Hashtable;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 判断 传入的字符串 是否符合特定的格式 * * @author 王明 * @date 2018-11-18 * */public class FieldValidationUtil &#123; /** * 根据验证类型 判断传入的字符串是否符合规则 * @author wangming * * 0 非空 * 1 手机号 * 2 验证固定电话 * 3 日期(支持 yyyy-MM-dd和yyyyMMdd) * 4 邮箱 * 4 身份证号 * 6 姓名 * 7 验证英文名 * 8 邮编 * 9 验证出生日期 * 10 数字 * 11 小数点后两位的数字 * 12 护照 * 13 企业姓名 * 14 企业证件号 * 15 台湾居民来往大陆通行证,港澳同胞回乡证 * 16 校验军官证 * 17 校验出生证明 * 18 校验港澳台居民居住证 * @return boolean 正确返回 true 否则 false */ public static boolean vailStringByType(int authType,String value)&#123; switch(authType)&#123; // 验证非空 case 0:&#123; if(null==value)&#123; return false; &#125; else&#123; if("".equals(value.trim()))&#123; return false; &#125;else&#123; return true; &#125; &#125; &#125; // 验证手机号 case 1:&#123; Pattern p = null; Matcher m = null; p = Pattern.compile(ValidationPropertiesUtil.getProperty("mobile")); // 验证手机号 m = p.matcher(value); boolean b = m.matches(); return b; &#125; //验证固定电话 case 2:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("tel")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证日期 case 3:&#123; value=value.replaceAll("/","").replaceAll("-",""); if(value!=null&amp;&amp;!"".equals(value.trim()) &amp;&amp; value.length()==8)&#123; SimpleDateFormat sdf2=new SimpleDateFormat("yyyyMMdd");//小写的mm表示的是分钟 try &#123; sdf2.setLenient(false); sdf2.parse(value); return true; &#125; catch (ParseException e1) &#123; e1.printStackTrace(); return false; &#125; &#125;else&#123; return false; &#125; &#125; // 验证 邮箱 case 4:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("email")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证 身份证号 case 5:&#123; boolean b = vailIdCardNum(value); return b; &#125; // 验证姓名类型 case 6:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("name")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //验证英文名 case 7:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("ename")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //邮编 case 8:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("postCode")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证出生日期 case 9:&#123; value=value.replaceAll("/","").replaceAll("-",""); if(value!=null&amp;&amp;!"".equals(value.trim()) &amp;&amp; value.length()==8)&#123; SimpleDateFormat sdf2=new SimpleDateFormat("yyyyMMdd");//小写的mm表示的是分钟 SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");//小写的mm表示的是分钟 try &#123; sdf2.setLenient(false); sdf2.parse(value); String strYear = value.substring(0, 4);// 年份 String strMonth = value.substring(4, 6);// 月份 String strDay = value.substring(6, 8);// 月份 if (isDataFormat(strYear + "-" + strMonth + "-" + strDay) == false) &#123; return false; &#125; GregorianCalendar gc = new GregorianCalendar(); if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; 200 || (gc.getTime().getTime() - sdf.parse( strYear + "-" + strMonth + "-" + strDay).getTime()) &lt; 0) &#123; return false; &#125; if (Integer.parseInt(strMonth) &gt; 12 || Integer.parseInt(strMonth) == 0) &#123; return false; &#125; if (Integer.parseInt(strDay) &gt; 31 || Integer.parseInt(strDay) == 0) &#123; return false; &#125; // =====================(end)===================== return true; &#125; catch (ParseException e1) &#123; e1.printStackTrace(); return false; &#125; &#125;else&#123; return false; &#125; &#125; // 验证 数字 case 10:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("num")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //小数点后两位的数字 case 11:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("floatCheck")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证 护照 case 12:&#123; boolean b = checkPassportNumber(value); return b; &#125; //企业姓名 case 13:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("firmName")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //企业证件号 case 14:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("idCardNumber")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //台湾居民来往大陆通行证,港澳同胞回乡证 case 15:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("chinaOtherCard")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验军官证 case 16:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("officerNumber")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验出生证明 case 17:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("birthCard")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验港澳台居民居住证 case 18:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("gatNumber")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //小数点后两位的数字 case 19:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("salryCheck")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; default:&#123; return false; &#125; &#125; &#125; /** * 验证身份证号 * @param IDStr * @return * @throws NumberFormatException * @throws ParseException */ public static boolean vailIdCardNum(String IDStr)&#123; try &#123; if(IDStr==null)&#123; return false; &#125;else&#123; IDStr = IDStr.toLowerCase(); &#125; String[] ValCodeArr = &#123; "1", "0", "x", "9", "8", "7", "6", "5", "4", "3", "2" &#125;; String[] Wi = &#123; "7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2" &#125;; String Ai = ""; // ================ 号码的长度 15位或18位 ================ if (IDStr.length() != 15 &amp;&amp; IDStr.length() != 18) &#123; return false; &#125; // ================ 数字 除最后以为都为数字 ================ if (IDStr.length() == 18) &#123; Ai = IDStr.substring(0, 17); &#125; else if (IDStr.length() == 15) &#123; Ai = IDStr.substring(0, 6) + "19" + IDStr.substring(6, 15); &#125; if (vailStringByType(8,Ai) == false) &#123; return false; &#125; // =======================(end)======================== // ================ 出生年月是否有效 ================ String strYear = Ai.substring(6, 10);// 年份 String strMonth = Ai.substring(10, 12);// 月份 String strDay = Ai.substring(12, 14);// 月份 if (isDataFormat(strYear + "-" + strMonth + "-" + strDay) == false) &#123; return false; &#125; GregorianCalendar gc = new GregorianCalendar(); SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd"); if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; 200 || (gc.getTime().getTime() - s.parse( strYear + "-" + strMonth + "-" + strDay).getTime()) &lt; 0) &#123; return false; &#125; if (Integer.parseInt(strMonth) &gt; 12 || Integer.parseInt(strMonth) == 0) &#123; return false; &#125; if (Integer.parseInt(strDay) &gt; 31 || Integer.parseInt(strDay) == 0) &#123; return false; &#125; // =====================(end)===================== // ================ 地区码时候有效 ================ Hashtable&lt;String, String&gt; h = GetAreaCode(); if (h.get(Ai.substring(0, 2)) == null) &#123; return false; &#125; // ============================================== // ================ 判断最后一位的值 ================ int TotalmulAiWi = 0; for (int i = 0; i &lt; 17; i++) &#123; TotalmulAiWi = TotalmulAiWi + Integer.parseInt(String.valueOf(Ai.charAt(i))) * Integer.parseInt(Wi[i]); &#125; int modValue = TotalmulAiWi % 11; String strVerifyCode = ValCodeArr[modValue]; Ai = Ai + strVerifyCode; if (IDStr.length() == 18) &#123; if (!Ai.equals(IDStr)) &#123; return false; &#125; &#125; else &#123; return true; &#125; // =====================(end)===================== return true; &#125; catch (NumberFormatException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return false; &#125; /** * 功能：设置地区编码 * @return Hashtable 对象 */ private static Hashtable&lt;String, String&gt; GetAreaCode() &#123; Hashtable&lt;String, String&gt; hashtable = new Hashtable&lt;String, String&gt;(); hashtable.put("11", "北京"); hashtable.put("12", "天津"); hashtable.put("13", "河北"); hashtable.put("14", "山西"); hashtable.put("15", "内蒙古"); hashtable.put("21", "辽宁"); hashtable.put("22", "吉林"); hashtable.put("23", "黑龙江"); hashtable.put("31", "上海"); hashtable.put("32", "江苏"); hashtable.put("33", "浙江"); hashtable.put("34", "安徽"); hashtable.put("35", "福建"); hashtable.put("36", "江西"); hashtable.put("37", "山东"); hashtable.put("41", "河南"); hashtable.put("42", "湖北"); hashtable.put("43", "湖南"); hashtable.put("44", "广东"); hashtable.put("45", "广西"); hashtable.put("46", "海南"); hashtable.put("50", "重庆"); hashtable.put("51", "四川"); hashtable.put("52", "贵州"); hashtable.put("53", "云南"); hashtable.put("54", "西藏"); hashtable.put("61", "陕西"); hashtable.put("62", "甘肃"); hashtable.put("63", "青海"); hashtable.put("64", "宁夏"); hashtable.put("65", "新疆"); hashtable.put("71", "台湾"); hashtable.put("81", "香港"); hashtable.put("82", "澳门"); hashtable.put("91", "国外"); return hashtable; &#125; /** * @desc 校验护照 * @param value * @return boolean */ private static boolean checkPassportNumber(String value) &#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty("passportNumber")); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; /**验证日期字符串是否是YYYY-MM-DD格式 * @param str * @return */ private static boolean isDataFormat(String str)&#123; boolean flag=false; String regxStr=ValidationPropertiesUtil.getProperty("dateFormat"); Pattern pattern1=Pattern.compile(regxStr); Matcher isNo=pattern1.matcher(str); if(isNo.matches())&#123; flag=true; &#125; return flag; &#125; //验证出生日期是否在当前日期之前 public static boolean validationBirthDate(Date birthDate)&#123; Date date =new Date(); int number=date.compareTo(birthDate); if(number&gt;0)&#123; return true; &#125;else&#123; return false; &#125; &#125; /** * * @param str 字符串 * @param flag 1 过滤全部字符串 、 2 过滤收尾字符串 * @return */ public static String trim(String str,Integer flag)&#123; if(flag == 1)&#123; return str.replaceAll(" ", ""); &#125;else if(flag == 2)&#123; return str.trim(); &#125; return str; &#125; /** * 判断字符串中是否包含中文 * @param str * 待校验字符串 * @return 是否为中文 * @warn 不能校验是否为中文标点符号 */ public static boolean isContainChinese(String str) &#123; Pattern p = Pattern.compile(ValidationPropertiesUtil.getProperty("is_chinese")); Matcher m = p.matcher(str); if (m.find()) &#123; return true; &#125; return false; &#125; /** * 过滤后空格的字符串 * @param str * @return */ public static String getAfterTrimStr(String str)&#123; if(str!=null&amp;&amp;!"".equals(str))&#123; if(isContainChinese(str))&#123; return trim(str,1); &#125;else&#123; return trim(str,2); &#125; &#125; return ""; &#125; /** * 身份证号的特殊字符转化 * @param str * @return */ public static String getIdCardNumberStr(String str)&#123; if(str!=null&amp;&amp;!"".equals(str))&#123; return str.toUpperCase().replace("×", "X").replace("x", "X"); &#125; return ""; &#125; /** * 证件有效期判断转换 */ public static String cardDate(String idStartDate , String idEndDate,String isLongterm)&#123; String cardDateString=""; if(idStartDate=="" || idStartDate==null)&#123; return cardDateString; &#125; if("1".equals(isLongterm) || "".equals(idEndDate) || idEndDate == null) &#123; cardDateString = idStartDate + "-" +"长期"; &#125;else &#123; cardDateString = idStartDate + "-" + idEndDate; &#125; return cardDateString; &#125; &#125; ValidationPropertiesUtil.java123456789101112131415161718192021222324252627282930package com.common.utils.register;import java.io.IOException;import java.util.Properties;/** * @author wangming * @version * 读取获取配置文件相关信息 * */public class ValidationPropertiesUtil &#123; private static Properties p = System.getProperties(); private static ValidationPropertiesUtil propertiesUtil = null; private ValidationPropertiesUtil()&#123; try &#123; p.load(ValidationPropertiesUtil.class.getResourceAsStream("validation.properties")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String getProperty(String key)&#123; if(propertiesUtil == null)&#123; propertiesUtil = new ValidationPropertiesUtil(); &#125; return p.getProperty(key); &#125; public static void clear()&#123; p.clear(); &#125;&#125; validation.properties1234567891011121314151617181920212223242526272829303132#手机号码校验规则mobile = ^(13|14|15|17|18|19|16)[0-9]&#123;9&#125;$#验证固定电话tel = ^(0[1-9][0-9])-\d&#123;8&#125;$|^(0[1-9]&#123;3&#125;-(\d&#123;7,8&#125;))$#邮件检验email = ^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.([a-zA-Z0-9_-])+)+$#姓名name = ^[\u0391-\uffe5]&#123;2,20&#125;$|^[a-zA-Z\\s]&#123;2,20&#125;$#name = ^[\\u4e00-\\u9fa5]&#123;1&#125;[\\u4e00-\\u9fa5\.·。]&#123;0,20&#125;[\\u4e00-\\u9fa5]&#123;1&#125;$)|([a-zA-Z]&#123;1&#125;[a-zA-Z\\-]&#123;0,20&#125;[a-zA-Z]&#123;1&#125;$#英文姓名ename:^[a-zA-Z \s]&#123;2,20&#125;$#邮编postCode=^[0-9]\\d&#123;5&#125;$#数字num = ^[0-9]*$#小数点后两位数字floatCheck = ^[0-9]+(.[0-9]&#123;1,2&#125;)?$salryCheck = \\d\\.\\d*|[1-9]\\d*|\\d*\\.\\d*|\\d#校验护照passportNumber = ^[a-zA-Z0-9]&#123;3,16&#125;$#企业姓名firmName=^([A-Za-z]|[\u4E00-\u9FA5]|\\\\uFF08|\\\\uFF09)&#123;2,30&#125;$#企业证件号idCardNumber=^[0-9a-zA-Z]+$#台湾居民来往大陆通行证,港澳同胞回乡证chinaOtherCard=^[\\\d\\\D]&#123;8,18&#125;$#校验军官证officerNumber=^[a-zA-Z0-9-\u4e00-\u9fa5]&#123;10,18&#125;$#校验出生证明birthCard=^[0-9a-zA-Z]&#123;1,18&#125;$#校验港澳台居民居住证gatNumber=^(810000|820000|830000)[A-Z0-9]&#123;12&#125;$ Test.java123456package com.common.utils.register;public class Test &#123; public static void main(String[] args) &#123; System.out.println(FieldValidationUtil.vailStringByType(6, "哈哈哈")); &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java字段校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成随机数工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述生成制定范围内的随机数、返回固定长度的数字、返回一个定长的随机字符串(只包含大小写字母、数字)、返回一个定长的随机纯字母字符串(只包含大小写字母)、返回一个定长的随机纯大写字母字符串(只包含大小写字母)、返回一个UUID等等。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299package com.common.utils.random;import java.util.*;public final class RandomUtil &#123; public static final String ALLCHAR = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; public static final String LETTERCHAR = "abcdefghijkllmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; public static final String NUMBERCHAR = "0123456789"; /** * 生成制定范围内的随机数 * * @param scopeMin * @param scoeMax * @return */ public static int integer(int scopeMin, int scoeMax) &#123; Random random = new Random(); return (random.nextInt(scoeMax) % (scoeMax - scopeMin + 1) + scopeMin); &#125; /** * 返回固定长度的数字 * * @param length * @return */ public static String number(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(NUMBERCHAR.charAt(random.nextInt(NUMBERCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机字符串(只包含大小写字母、数字) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String String(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(ALLCHAR.charAt(random.nextInt(ALLCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机纯字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String MixString(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(ALLCHAR.charAt(random.nextInt(LETTERCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机纯大写字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String LowerString(int length) &#123; return MixString(length).toLowerCase(); &#125; /** * 返回一个定长的随机纯小写字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String UpperString(int length) &#123; return MixString(length).toUpperCase(); &#125; /** * 生成一个定长的纯0字符串 * * @param length 字符串长度 * @return 纯0字符串 */ public static String ZeroString(int length) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; length; i++) &#123; sb.append('0'); &#125; return sb.toString(); &#125; /** * 根据数字生成一个定长的字符串，长度不够前面补0 * * @param num 数字 * @param fixdlenth 字符串长度 * @return 定长的字符串 */ public static String toFixdLengthString(long num, int fixdlenth) &#123; StringBuffer sb = new StringBuffer(); String strNum = String.valueOf(num); if (fixdlenth - strNum.length() &gt;= 0) &#123; sb.append(ZeroString(fixdlenth - strNum.length())); &#125; else &#123; throw new RuntimeException("将数字" + num + "转化为长度为" + fixdlenth + "的字符串发生异常！"); &#125; sb.append(strNum); return sb.toString(); &#125; /** * 根据数字生成一个定长的字符串，长度不够前面补0 * * @param num 数字 * @param fixdlenth 字符串长度 * @return 定长的字符串 */ public static String toFixdLengthString(int num, int fixdlenth) &#123; StringBuffer sb = new StringBuffer(); String strNum = String.valueOf(num); if (fixdlenth - strNum.length() &gt;= 0) &#123; sb.append(ZeroString(fixdlenth - strNum.length())); &#125; else &#123; throw new RuntimeException("将数字" + num + "转化为长度为" + fixdlenth + "的字符串发生异常！"); &#125; sb.append(strNum); return sb.toString(); &#125; /** * 每次生成的len位数都不相同 * * @param param * @return 定长的数字 */ public static int getNotSimple(int[] param, int len) &#123; Random rand = new Random(); for (int i = param.length; i &gt; 1; i--) &#123; int index = rand.nextInt(i); int tmp = param[index]; param[index] = param[i - 1]; param[i - 1] = tmp; &#125; int result = 0; for (int i = 0; i &lt; len; i++) &#123; result = result * 10 + param[i]; &#125; return result; &#125; /** * 从指定的数组中随机数组中的某个元素 */ public static &lt;T&gt; T randomItem(T[] param) &#123; int index = integer(0, param.length); return param[index]; &#125; /** * 实现一个简单的字符串乘法 * @param str * @param multiplication * @return */ private static String strMultiplication(String str,int multiplication)&#123; StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; multiplication; i++) &#123; buffer.append(str); &#125; return buffer.toString(); &#125; /** * 从指定的数组中按照指定比例返回指定的随机元素 * @param param * @param percentum * @param &lt;T&gt; * @return */ public static &lt;T&gt; T randomItem(T[] param,double[] percentum)&#123; int length = percentum.length; Integer[] ints = doubleBitCount(percentum); int max = Collections.max(Arrays.asList(ints)); int[] arr = new int[length]; int sum = 0; Map map = new HashMap(length); int multiple = Integer.parseInt("1"+strMultiplication("0",max)); for (int i = 0; i &lt; length; i++) &#123; int temp = (int)(percentum[i] * multiple); arr[i] = temp; if(i == 0)&#123; map.put(i,new int[]&#123;1,temp&#125;); &#125;else&#123; map.put(i,new int[]&#123;sum,sum+temp&#125;); &#125; sum += temp; &#125; int indexSum = integer(1,sum); int index =-1; for (int i = 0; i &lt; length; i++) &#123; int[] scope = (int[]) map.get(i); if(indexSum ==1 )&#123; index = 0; break; &#125; if(indexSum &gt; scope[0] &amp;&amp; indexSum &lt;= scope[1])&#123; index =i; break; &#125; &#125; if(index == -1)&#123; throw new RuntimeException("随机失败"); &#125;else&#123; return param[index]; &#125; &#125; /** * 返回一个UUID * * @return 小写的UUID */ public static String uuid() &#123; UUID uuid = UUID.randomUUID(); String s = uuid.toString(); return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24); &#125; /** * 返回一个UUID * * @return 大写的UUID */ public static String UUID() &#123; UUID uuid = UUID.randomUUID(); String s = uuid.toString(); String temp = s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24); return temp.toUpperCase(); &#125; /** * 返回一个有序列的uuid编码 * 前11位为时间(毫秒) * 中间4位为主机特征码 * 剩下的保证其唯一性 * * @return */ public static String squid() &#123; Long date = new Date().getTime(); String s = UUID.randomUUID().toString(); String str = Long.toHexString(date); String result = str + "0001" + s.substring(17, 18) + s.substring(19, 23) + s.substring(24); return result.toUpperCase(); &#125; /** * 获取一个double类型的数字的小数位有多长 * @param arr double类型的数组 * @return integer类型长度值 */ public static Integer[] doubleBitCount(double[] arr)&#123; Integer[] len = new Integer[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; len[i] = doueleBitCount(arr[i]); &#125; return len; &#125; /** * 获取一个double类型的数字的小数位有多长 * @param dd * @return */ public static int doueleBitCount(double dd)&#123; String temp = String.valueOf(dd); int i = temp.indexOf("."); if(i &gt; -1)&#123; return temp.length()-i -1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java生成随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml相关的工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fxml%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述读取xml数据返回string数据xml与map的相互转换 代码读取xml转换成string 12345678910111213141516171819202122232425262728293031package com.common.utils.xml;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * 读取xml数据 * @author wangming * return String 类型数据 */public class ReadXmlFileToString &#123; public static String readXmlString(String filePath) &#123; String str=""; File file = new File(filePath); try &#123; FileInputStream in = new FileInputStream(file); // size 为字串的长度 ，这里一次性读完 int size=in.available(); byte[] buffer=new byte[size]; in.read(buffer); in.close(); str=new String(buffer,"UTF-8"); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; return str; &#125;&#125; xml与map的相互转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.common.utils.xml;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.StringWriter;import java.util.HashMap;import java.util.Map;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * 微信开发所需工具类 * 注:该工具适用于一层xml格式,存在二级element时，不适用 * @author wangming * @see 转换的xml发送前需去换行符.replaceAll("\n|\r", "") * @see 因微信接口在后期发展会增加返回字段，所以xml先转map再转obj * */public class XmlMapUtil &#123; /** * XML格式字符串转换为Map * * @param strXML XML字符串 * @return XML数据转换后的Map * @throws Exception */ public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123; try &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes("UTF-8")); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) &#123; Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); &#125; &#125; try &#123; stream.close(); &#125; catch (Exception ex) &#123; // do nothing &#125; return data; &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; /** * 将Map转换为XML格式的字符串 * * @param data Map类型数据 * @return XML格式的字符串 * @throws Exception */ public static String mapToXml(Map&lt;String, String&gt; data) throws Exception &#123; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); org.w3c.dom.Document document = documentBuilder.newDocument(); org.w3c.dom.Element root = document.createElement("xml"); document.appendChild(root); for (String key: data.keySet()) &#123; String value = data.get(key); if (value == null) &#123; value = ""; &#125; value = value.trim(); org.w3c.dom.Element filed = document.createElement(key); filed.appendChild(document.createTextNode(value)); root.appendChild(filed); &#125; TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = tf.newTransformer(); DOMSource source = new DOMSource(document); transformer.setOutputProperty(OutputKeys.ENCODING, "UTF-8"); transformer.setOutputProperty(OutputKeys.INDENT, "no"); transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "no"); StringWriter writer = new StringWriter(); StreamResult result = new StreamResult(writer); transformer.transform(source, result); String output = writer.getBuffer().toString(); //.replaceAll("\n|\r", ""); try &#123; writer.close(); &#125; catch (Exception ex) &#123; &#125; return output; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>读取xml转换成string map转换成xml xml转换成map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述为空或者null、不为空、String转换成int、String转换成long、切分string成数组 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.common.utils.string;/** * 字符串工具类 * @author wangming * 1 isEmpty() 为空或者null * 2 isNotEmpty() 不为空 * 3 parseStringInt() String转换成int * 4 parseStringLong() String转换成long * 5 parseStringArray() 切分string成数组 */public class StringUtil &#123; /** * 判断是否为空字符串最优代码 * @param str * @return 如果为空，则返回true */ public static boolean isEmpty(String str)&#123; return str == null || str.trim().length() == 0; &#125; /** * 判断字符串是否非空 * @param str 如果不为空，则返回true * @return */ public static boolean isNotEmpty(String str)&#123; return !isEmpty(str); &#125; /** * 将String类型转换成int类型 * @param str * @return */ public static int parseStringInt(String str) &#123; return Integer.parseInt(str); &#125; /** * 将String类型数据转换成long类型 * @param str * @return */ public static long parseStringLong(String str) &#123; return Long.parseLong(str); &#125; /** * 根据规则将string转换成数组 * @param str 字符串 * @param regex 规则 * @return 数组 */ public static String[] parseStringArray(String str,String regex) &#123; String [] arr = str.split(regex); return arr; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java字符串工具类 java字符串转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数学工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述加减乘除四舍五入 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.common.utils.math;import java.math.BigDecimal;/** * 数学工具类 * 加减乘除四舍五入 * @author wangming * */public class Arith &#123; private static final int DEF_DIV_SCALE = 10; // 这个类不能实例化 private Arith() &#123; &#125; /** * 提供精确的加法运算。 * * @param v1 * 被加数 * @param v2 * 加数 * @return 两个参数的和 */ public static double add(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); &#125; /** * 提供精确的减法运算。 * * @param v1 * 被减数 * @param v2 * 减数 * @return 两个参数的差 */ public static double sub(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); &#125; /** * 提供精确的乘法运算。 * * @param v1 * 被乘数 * @param v2 * 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 小数点以后10位，以后的数字四舍五入。 * * @param v1 * 被除数 * @param v2 * 除数 * @return 两个参数的商 */ public static double div(double v1, double v2) &#123; return div(v1, v2, DEF_DIV_SCALE); &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 定精度，以后的数字四舍五入。 * * @param v1 * 被除数 * @param v2 * 除数 * @param scale * 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( "The scale must be a positive integer or zero"); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的小数位四舍五入处理。 * * @param v * 需要四舍五入的数字 * @param scale * 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( "The scale must be a positive integer or zero"); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal("1"); return b.divide(one, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java数学工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java加密工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java加密工具类包含AES、DES、Base32、Base64 AES代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.common.utils.encrypt;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Scanner;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** * AES对称加密和解密 * @auth wangming */public class AESUtil &#123; public static String encodeRules = "123456789"; /** * 加密 * 1.构造密钥生成器 * 2.根据ecnodeRules规则初始化密钥生成器 * 3.产生密钥 * 4.创建和初始化密码器 * 5.内容加密 * 6.返回字符串 */ public static String AESEncode(String encodeRules,String content)&#123; try &#123; //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen = KeyGenerator.getInstance("AES"); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key = keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw = original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key = new SecretKeySpec(raw, "AES"); //6.根据指定算法AES自成密码器 Cipher cipher = Cipher.getInstance("AES"); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.ENCRYPT_MODE, key); //8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码 byte [] byte_encode = content.getBytes("utf-8"); //9.根据密码器的初始化方式--加密：将数据加密 byte [] byte_AES = cipher.doFinal(byte_encode); //10.将加密后的数据转换为字符串 //这里用Base64Encoder中会找不到包 //解决办法： //在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。 String AES_encode = new String(new BASE64Encoder().encode(byte_AES)); //11.将字符串返回 return AES_encode; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; //如果有错就返加nulll return null; &#125; /** * 解密 * 解密过程： * 1.同加密1-4步 * 2.将加密后的字符串反纺成byte[]数组 * 3.将加密内容解密 */ public static String AESDncode(String encodeRules,String content)&#123; try &#123; //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen = KeyGenerator.getInstance("AES"); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key = keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw=original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key = new SecretKeySpec(raw, "AES"); //6.根据指定算法AES自成密码器 Cipher cipher = Cipher.getInstance("AES"); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.DECRYPT_MODE, key); //8.将加密并编码后的内容解码成字节数组 byte [] byte_content = new BASE64Decoder().decodeBuffer(content); /** * 解密 */ byte [] byte_decode = cipher.doFinal(byte_content); String AES_decode = new String(byte_decode,"utf-8"); return AES_decode; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; //如果有错就返加nulll return null; &#125; public static void main(String[] args) &#123; AESUtil se = new AESUtil(); Scanner scanner = new Scanner(System.in); /** * 加密 */ System.out.println("使用AES对称加密，请输入加密的规则"); String encodeRules = scanner.next(); System.out.println("请输入要加密的内容:"); String content = scanner.next(); System.out.println("根据输入的规则"+encodeRules+"加密后的密文是:"+se.AESEncode(encodeRules, content)); /** * 解密 */ System.out.println("使用AES对称解密，请输入加密的规则：(须与加密相同)"); encodeRules = scanner.next(); System.out.println("请输入要解密的内容（密文）:"); content = scanner.next(); System.out.println("根据输入的规则"+encodeRules+"解密后的明文是:"+se.AESDncode(encodeRules, content)); &#125;&#125; MD5代码 1234567891011121314151617181920212223242526272829303132333435363738394041package com.common.utils.encrypt;import java.nio.charset.Charset;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * 根据字符串md5加密 * 字符串长度小于1024*2 * @author wangming * */public class MD5Util &#123; private static final int MD5_LENGTH = 1024 * 2;//1024 * 2 - 512 public static String generateMD5(String plainText) &#123; try &#123; if(null == plainText || plainText.length() == 0) &#123; return null; &#125; plainText = (plainText.length() &gt; MD5_LENGTH)? plainText.substring(0, MD5_LENGTH) : plainText; MessageDigest md = MessageDigest.getInstance("MD5"); byte[] bytes = plainText.getBytes(Charset.forName("UTF-8")); md.update(bytes); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(""); for (int offset = 0, j = b.length; offset &lt; j; offset++) &#123; i = b[offset]; if (i &lt; 0) &#123; i += 256; &#125; if (i &lt; 16) &#123; buf.append("0"); &#125; buf.append(Integer.toHexString(i)); &#125; return buf.toString().toLowerCase(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; Base32代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.common.utils.encrypt;/** * Base32的编码和解码 */public final class Base32 &#123; private static final String ERR_CANONICAL = "Invalid Base32 string"; private static final char[] CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".toCharArray(); private static final byte[] LOOKUP = &#123; 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 0123456789:;&lt;=&gt;? -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, // PQRSTUVWXYZ[\]^_ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // `abcdefghijklmno 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 // pqrstuvwxyz &#125;; /** * 使用Base32进行编码 * * @param bytes * @return */ public final static String encode(final byte[] bytes) &#123; StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i &lt; bytes.length) &#123; // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] &amp; 255; base32.append(CHARS[currByte &gt;&gt; 3]); digit = (currByte &amp; 7) &lt;&lt; 2; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 6)]); base32.append(CHARS[(currByte &gt;&gt; 1) &amp; 31]); digit = (currByte &amp; 1) &lt;&lt; 4; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 4)]); digit = (currByte &amp; 15) &lt;&lt; 1; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 7)]); base32.append(CHARS[(currByte &gt;&gt; 2) &amp; 31]); digit = (currByte &amp; 3) &lt;&lt; 3; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 5)]); base32.append(CHARS[currByte &amp; 31]); &#125; return base32.toString(); &#125; /** * 用Base32进行解码 * * @param base32 * @return * @throws IllegalArgumentException */ public final static String decode(final String base32) throws IllegalArgumentException &#123; switch (base32.length() % 8) &#123; case 1: case 3: case 6: throw new IllegalArgumentException(ERR_CANONICAL); &#125; byte[] bytes = new byte[base32.length() * 5 / 8]; int offset = 0, i = 0, lookup; byte nextByte, digit; while (i &lt; base32.length()) &#123; lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 0: leave 5 bits nextByte = (byte) (digit &lt;&lt; 3); lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 5: insert 3 bits, leave 2 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 2)); nextByte = (byte) ((digit &amp; 3) &lt;&lt; 6); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 2: leave 7 bits nextByte |= (byte) (digit &lt;&lt; 1); lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 7: insert 1 bit, leave 4 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 4)); nextByte = (byte) ((digit &amp; 15) &lt;&lt; 4); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 4: insert 4 bits, leave 1 bit bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 1)); nextByte = (byte) ((digit &amp; 1) &lt;&lt; 7); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 1: leave 6 bits nextByte |= (byte) (digit &lt;&lt; 2); lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 6: insert 2 bits, leave 3 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 3)); nextByte = (byte) ((digit &amp; 7) &lt;&lt; 5); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - '2'; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 3: insert 5 bits, leave 0 bit bytes[offset++] = (byte) (nextByte | digit); &#125; return new String(bytes); &#125;&#125; Base64代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297package com.common.utils.encrypt;import java.io.UnsupportedEncodingException;import java.util.Arrays;/** * Base64的编码和解码 */public final class Base64 &#123; private static final char[] CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".toCharArray(); private static final int[] INV = new int[256]; static &#123; Arrays.fill(INV, -1); for (int i = 0, iS = CHARS.length; i &lt; iS; i++) &#123; INV[CHARS[i]] = i; &#125; INV['='] = 0; &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;char[]&lt;/code&gt;. * * @param lineSeparator optional CRLF after 76 chars, unless EOF. */ public final static char[] encodeToChar(byte[] arr, boolean lineSeparator) &#123; int len = arr != null ? arr.length : 0; if (len == 0) &#123; return new char[0]; &#125; int evenlen = (len / 3) * 3; int cnt = ((len - 1) / 3 + 1) &lt;&lt; 2; int destLen = cnt + (lineSeparator ? (cnt - 1) / 76 &lt;&lt; 1 : 0); char[] dest = new char[destLen]; for (int s = 0, d = 0, cc = 0; s &lt; evenlen; ) &#123; int i = (arr[s++] &amp; 0xff) &lt;&lt; 16 | (arr[s++] &amp; 0xff) &lt;&lt; 8 | (arr[s++] &amp; 0xff); dest[d++] = CHARS[(i &gt;&gt;&gt; 18) &amp; 0x3f]; dest[d++] = CHARS[(i &gt;&gt;&gt; 12) &amp; 0x3f]; dest[d++] = CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[d++] = CHARS[i &amp; 0x3f]; if (lineSeparator &amp;&amp; (++cc == 19) &amp;&amp; (d &lt; (destLen - 2))) &#123; dest[d++] = '\r'; dest[d++] = '\n'; cc = 0; &#125; &#125; int left = len - evenlen; // 0 - 2. if (left &gt; 0) &#123; int i = ((arr[evenlen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((arr[len - 1] &amp; 0xff) &lt;&lt; 2) : 0); dest[destLen - 4] = CHARS[i &gt;&gt; 12]; dest[destLen - 3] = CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[destLen - 2] = left == 2 ? CHARS[i &amp; 0x3f] : '='; dest[destLen - 1] = '='; &#125; return dest; &#125; public final static byte[] encodeToByte(String s) &#123; try &#123; return encodeToByte(s.getBytes("UTF_8"), false); &#125; catch (UnsupportedEncodingException ignore) &#123; return new byte[]&#123;&#125;; &#125; &#125; public final static byte[] encodeToByte(String s, boolean lineSep) &#123; try &#123; return encodeToByte(s.getBytes("UTF_8"), lineSep); &#125; catch (UnsupportedEncodingException ignore) &#123; return new byte[]&#123;&#125;; &#125; &#125; public final static byte[] encodeToByte(byte[] arr) &#123; return encodeToByte(arr, false); &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;char[]&lt;/code&gt;. * * @param lineSep optional CRLF after 76 chars, unless EOF. */ public final static byte[] encodeToByte(byte[] arr, boolean lineSep) &#123; int len = arr != null ? arr.length : 0; if (len == 0) &#123; return new byte[0]; &#125; int evenlen = (len / 3) * 3; int cnt = ((len - 1) / 3 + 1) &lt;&lt; 2; int destlen = cnt + (lineSep ? (cnt - 1) / 76 &lt;&lt; 1 : 0); byte[] dest = new byte[destlen]; for (int s = 0, d = 0, cc = 0; s &lt; evenlen; ) &#123; int i = (arr[s++] &amp; 0xff) &lt;&lt; 16 | (arr[s++] &amp; 0xff) &lt;&lt; 8 | (arr[s++] &amp; 0xff); dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 18) &amp; 0x3f]; dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 12) &amp; 0x3f]; dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[d++] = (byte) CHARS[i &amp; 0x3f]; if (lineSep &amp;&amp; ++cc == 19 &amp;&amp; d &lt; destlen - 2) &#123; dest[d++] = '\r'; dest[d++] = '\n'; cc = 0; &#125; &#125; int left = len - evenlen; if (left &gt; 0) &#123; int i = ((arr[evenlen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((arr[len - 1] &amp; 0xff) &lt;&lt; 2) : 0); dest[destlen - 4] = (byte) CHARS[i &gt;&gt; 12]; dest[destlen - 3] = (byte) CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[destlen - 2] = left == 2 ? (byte) CHARS[i &amp; 0x3f] : (byte) '='; dest[destlen - 1] = '='; &#125; return dest; &#125; public final static String decodeToString(byte[] arr) &#123; try &#123; return new String(decode(arr), "UTF_8"); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; /** * Decodes BASE64 encoded byte array. */ public final static byte[] decode(byte[] arr) &#123; int length = arr.length; if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (arr[76] == '\r' ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[arr[sndx++]] &lt;&lt; 18 | INV[arr[sndx++]] &lt;&lt; 12 | INV[arr[sndx++]] &lt;&lt; 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[arr[sndx++]] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125; public final static String encodeToString(String s) &#123; try &#123; return new String(encodeToChar(s.getBytes("UTF_8"), false)); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; public final static String encodeToString(String s, boolean lineSep) &#123; try &#123; return new String(encodeToChar(s.getBytes("UTF_8"), lineSep)); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; public final static String encodeToString(byte[] arr) &#123; return new String(encodeToChar(arr, false)); &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;String&lt;/code&gt;. */ public final static String encodeToString(byte[] arr, boolean lineSep) &#123; return new String(encodeToChar(arr, lineSep)); &#125; public final static String decodeToString(String s) &#123; try &#123; return new String(decode(s), "UTF_8"); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; /** * Decodes a BASE64 encoded string. */ public final static byte[] decode(String s) &#123; int length = s.length(); if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = s.charAt(endx) == '=' ? (s.charAt(endx - 1) == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (s.charAt(76) == '\r' ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[s.charAt(sndx++)] &lt;&lt; 18 | INV[s.charAt(sndx++)] &lt;&lt; 12 | INV[s.charAt(sndx++)] &lt;&lt; 6 | INV[s.charAt(sndx++)]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[s.charAt(sndx++)] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125; /** * Decodes a BASE64 encoded char array. */ public final byte[] decode(char[] arr) &#123; int length = arr.length; if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = arr[endx] == '=' ? (arr[endx - 1] == '=' ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (arr[76] == '\r' ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[arr[sndx++]] &lt;&lt; 18 | INV[arr[sndx++]] &lt;&lt; 12 | INV[arr[sndx++]] &lt;&lt; 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[arr[sndx++]] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java加密 AES DES Base32 Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java时间工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java时间工具类工具中提供获取当前年、月、日、String类型时间、Long当前毫秒数、日期格式化、根据string类型时间获取Long时间、根据Long类型时间获取当前String时间、获得当天某个时间的毫秒数等。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.common.utils.date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * * 用于处理时间的工具类 * @author wangming * */public class DateUtil &#123; /** * 获取当前年 * @return String */ public static int getCurrentYear()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.YEAR); &#125; /** * 获取当前月 * @return String */ public static int getCurrentMonth()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.MONTH)+1; &#125; /** * 获取当前日 * @return String */ public static int getCurrentDate()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.DATE); &#125; /** * 获取当前时分秒 * @return String */ public static String getCurrentTime()&#123; Calendar cl = Calendar.getInstance(); String hour = String.valueOf(cl.get(Calendar.HOUR_OF_DAY)); String minute = String.valueOf(cl.get(Calendar.MINUTE)); String second = String.valueOf(cl.get(Calendar.SECOND)); return hour+":"+minute+":"+second; &#125; /** * 获取当前毫秒数 * @return Long */ public static Long getCurrentDateTimeLong()&#123; Calendar cl = Calendar.getInstance(); Long time = cl.getTimeInMillis(); return time; &#125; /** * 获取当前时间 *@param format 要格式化的类型，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd *@return string类型时间 */ public static String getCurrentDateString(String format)&#123; Calendar cl = Calendar.getInstance(); Long time = cl.getTimeInMillis(); SimpleDateFormat sdf= new SimpleDateFormat(format); String dataString = sdf.format(time); return dataString; &#125; /** * 根据string类型时间获取Long时间 * @param date类型时间 * @param format 时间类型格式，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd * @return Long类型时间 */ public static Long getAssignLongTime(String date,String format) &#123; SimpleDateFormat sdf= new SimpleDateFormat(format); Date da = null; try &#123; da = sdf.parse(date); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return da.getTime(); &#125; /** * 根据Long类型时间获取当前String时间 * @param date类型时间 * @param format 要返回 时间类型格式，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd * @return String类型时间 */ public static String getAssignStringTime(Long time,String format) &#123; Date date = new Date(time); SimpleDateFormat sdf= new SimpleDateFormat(format); return sdf.format(date); &#125; /** * 获取昨天的日期 */ public static String getAccountDate()&#123; Date date = new Date(); Calendar c = Calendar.getInstance(); c.setTime(date); c.add(Calendar.DATE,-1); date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); String datestr = sdf.format(date); return datestr; &#125; /** * 获得当天某个时间的毫秒数 * @param hour 小时 * @param second 分钟 * @param minute 秒数 * @param millisecode 毫秒 */ public static long getTimesmorning(int hour,int second,int minute,int millisecode)&#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, hour);//获取小时 cal.set(Calendar.SECOND, second);//获取分钟 cal.set(Calendar.MINUTE, minute);//获取秒 cal.set(Calendar.MILLISECOND, millisecode);//获取毫秒 return cal.getTimeInMillis(); &#125; /** * 获得本月最后一天24点时间 */ public static long getTimesMonthnight()&#123; Calendar cal = Calendar.getInstance(); cal.set(cal.get(Calendar.YEAR),cal.get(Calendar.MONDAY), cal.get(Calendar.DAY_OF_MONTH), 0, 0,0); cal.set(Calendar.DAY_OF_MONTH,cal.getActualMaximum(Calendar.DAY_OF_MONTH)); cal.set(Calendar.HOUR_OF_DAY, 24); return cal.getTimeInMillis(); &#125; &#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java时间处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java多线程Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 线程生命周期1.新建状态（New）：新创建了一个线程对象。2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：4.1 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。4.2 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。4.3 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建线程通过实现 Runnable接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.thread;/** * 输出ABCABCABCABCABCABCABCABCABCABC * @author ming * */class RunnableDemo implements Runnable&#123; private String name; private Object prev; private Object self; private RunnableDemo(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); RunnableDemo pa = new RunnableDemo("A", c, a); RunnableDemo pb = new RunnableDemo("B", a, b); RunnableDemo pc = new RunnableDemo("C", b, c); new Thread(pa).start(); Thread.sleep(100); new Thread(pb).start(); Thread.sleep(100); new Thread(pc).start(); Thread.sleep(100); &#125; &#125; 通过继承 Thread类本身12345678910111213141516171819202122232425262728293031323334353637package com.thread;class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; this.name = name; &#125; public void run() &#123; for(int i=0; i&lt;5; i++) &#123; System.out.println(name+i); try &#123; sleep((int)Math.random()*10); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ExtendsTreadDemo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+"主线程运行开始!"); Thread1 thread1 = new Thread1("A"); Thread1 thread2 = new Thread1("B"); thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.start(); try &#123; thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ "主线程运行结束!"); &#125;&#125; 通过 Callable和 Future创建线程12345678910111213141516171819202122232425262728293031323334353637383940package com.thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableThreadDemo implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadDemo ctt = new CallableThreadDemo(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 10;i++) &#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==5) &#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+"call:"+i); &#125; return i; &#125; &#125; 同步代码块与同步方法这两个方法用的是一把锁，同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁，很明显，同步方法锁的范围比较大，而同步代码块范围要小点，一般同步的范围越大，性能就越差，一般需要加锁进行同步的时候，肯定是范围越小越好，这样性能更好。123456789101112131415161718192021222324package com.thread;public class SynchronizedDemo &#123; public synchronized void test1() &#123; for(int i= 0;i&lt;5 ; i++) &#123; System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125; public void test2() &#123; synchronized (this) &#123; for(int i= 0;i&lt;5 ; i++) &#123; System.out.println(Thread.currentThread().getName()+":"+i); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo sd = new SynchronizedDemo(); Thread t1 = new Thread(new Runnable() &#123;public void run() &#123;sd.test1();&#125;&#125;); Thread t2 = new Thread(new Runnable() &#123;public void run() &#123;sd.test2();&#125;&#125;); t1.start(); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程 java多线程 同步方法与同步代码快</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java回调函数]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[java回调函数简单来说，就是客户端调用服务起执行一个函数，当服务器端执行完成之后反过来调用客户端的函数，比如ajax进行异步调用。 简单示例 Student.java12345678package com.callback;public class Student &#123; public void doHomework() &#123; System.out.println("完成作业！"); Teacher teac = new Teacher(); teac.back(); &#125;&#125; Teacher.java1234567891011package com.callback;public class Teacher &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.doHomework(); &#125; public void back() &#123; System.out.println("老师我作业完成了！"); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>回调函数 java回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射？Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。 反射作用？我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等； 实现示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 反射的应用场合：在编译时根本无法知道该对象或类可能属于哪些类， * 程序只依靠运行时信息来发现该对象和类的真实信息. * @author wangming * */public class Person &#123; //私有属性 private String name = "test"; //公有属性 public int age = 20; //公有属性 public int sax = 1; //构造方法 public Person() &#123;&#125; //私有方法 private void say() &#123; System.out.println("this is private method!"); &#125; //共有方法 public void work() &#123; System.out.println("this is public method!"); &#125; public static void main(String[] args) &#123; try &#123; //通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object //类型的对象，而我不知道你具体是什么类，用这种方法 /* * Person person = new Person(); Class c1 = person.getClass(); */ //直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高 //这说明任何一个类都有一个隐含的静态成员变量 class Class c2 = Person.class; //通过 Class 对象的 forName() 静态方法来获取，用的最多， //但可能抛出 ClassNotFoundException 异常 /* * try &#123; Class c3 = Class.forName("com.reflect.Person"); &#125; catch * (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; */ //获得类完整的名字 // String className = c2.getName(); // System.out.println("className:"+className); //获得类的public类型的属性 // Field[] fields = c2.getFields(); // for(Field field:fields) &#123; // System.out.println(field.getName()); // &#125; //获得类的所有属性。包括私有的 // Field[] AllFields = c2.getDeclaredFields(); // for(Field field:AllFields) &#123; // System.out.println(field.getName()); // &#125; //获得类的public类型的方法。这里包括 Object 类的一些方法 // Method[] methods = c2.getMethods(); // for(Method method:methods) &#123; // System.out.println(method.getName()); // &#125; //获得类的所有方法 // Method[] allMethods = c2.getDeclaredMethods(); // for(Method method:allMethods) &#123; // System.out.println(method.getName()); // &#125; //获得指定的属性// Field f1 = c2.getField("age");// System.out.println(f1); //获得指定的私有属性 Field f2 = c2.getDeclaredField("name"); System.out.println(f2); //创建这个类的一个对象 Object p2 = c2.newInstance(); //将 p2 对象的 f2 属性赋值为 Bob，f2 属性即为 私有属性 name f2.set(p2, "test"); //使用反射机制可以打破封装性，导致了java对象的属性不安全 System.out.println(f2.get(p2)); //获取构造方法 Constructor[] constructors = c2.getConstructors(); for(Constructor constructor:constructors) &#123; System.out.println(constructor.getName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 原始链接https://www.cnblogs.com/ysocean/p/6516248.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射 java反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis使用]]></title>
    <url>%2F2019%2F01%2F20%2Fredis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境jdk1.8、redis数据库commons-pool2-2.6.0.jarjedis-2.9.0.jarcommons-logging-1.0.4.jarlog4j-1.2.16.jar 代码 1.com.redis.RedisUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.redis;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.apache.log4j.Logger;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * log4j(commons-logging/log4j) * redis(jedis/commons-pool2) * @author wangming * */public class RedisUtil &#123; private static JedisPool pool=null; //最大连接数 private static int max_active=50; //最大空闲数 private static int max_idle=40; //等待时间 private static long max_waitmillis=3000; //redis主机地址 private static String host; //redis端口 private static int port; //redis用户密码 private static String password; //过期时间 private static int expireTime = 2*60*60*1000; static Logger logger = Logger.getLogger(RedisUtil.class); static&#123; try &#123; //获取配置文件内容 InputStream in = RedisUtil.class.getResourceAsStream("redis.properties"); Properties prop = new Properties(); prop.load(in); RedisUtil.max_active = Integer.parseInt(prop.getProperty("max_active")); RedisUtil.max_idle = Integer.parseInt(prop.getProperty("max_idle")); RedisUtil.max_waitmillis = Long.parseLong(prop.getProperty("max_waitmillis").toString()); RedisUtil.host = prop.getProperty("host"); RedisUtil.port = Integer.parseInt(prop.getProperty("port")); RedisUtil.password = prop.getProperty("password"); //初始化连接池 RedisUtil.pool = initPool(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*** * 初始化连接池 * @return */ private static JedisPool initPool()&#123; JedisPool result = null; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(max_idle); config.setMaxWaitMillis(max_waitmillis); config.setTestOnBorrow(true); if(RedisUtil.password==null||"".equals(RedisUtil.password))&#123; result = new JedisPool(config,host,port); &#125;else&#123; result = new JedisPool(config,host,port,3000,RedisUtil.password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 向redis添加String，成功返回0，失败返回1 * @param String */ public static int set(String key,String value)&#123; if(value==null || key==null)&#123; logger.debug("redis存储对象时传入参数为空"); return 1; &#125; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); jedis.set(key, value); &#125;catch(Exception e)&#123; logger.debug("对象存储redis失败"); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /** * redis数据库查询 */ public static String get(String key)&#123; if(key==null)&#123; logger.debug("redis查询方法，传入参数为空"); return null; &#125; String result=""; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); result = jedis.get(key); &#125;catch(Exception e)&#123; logger.debug("redis查询方法执行失败"+e); &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return result; &#125; /** * 封装jedis的hset方法解释如下 * @param key * @param field 实体类的类名 * @param value 对应分项内容的json串 * @return */ public static long hset(String key,String field,String value)&#123; long result =0; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hset(key, field, value); //设置两小时过期 jedis.expire(key,expireTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 封装redis的hget方法,，解释如下 * @param key * @param field 对应实体类的类名 * @return result 对应分项内容的json串 */ public static String hget(String key,String field)&#123; String result =null; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hget(key, field); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 设置过期时间 * @param value 秒 * @return 成功返回0，失败返回1 */ public static int expire(String key,int value)&#123; if(key==null)&#123; logger.debug("redis设置失效时间，传入key参数为空"); return 1; &#125; Jedis jedis =null; try&#123; jedis = RedisUtil.getJedis(); jedis.expire(key, value); &#125;catch(Exception e)&#123; logger.debug("redis设置"+key+"失效时间失败"); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /*** * 获取Jedis实例 * @return Jedis实例 */ public static Jedis getJedis()&#123; Jedis result = null; try &#123; result = RedisUtil.pool.getResource(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /*** * 关闭 Jedis * @param jedis */ public static void closeJedis(Jedis jedis)&#123; if(jedis!=null)&#123; jedis.close(); &#125; &#125; public static void main(String[] args) &#123;// Jedis jedis = getJedis(); String openid = "o5lHPww7MK_ca1-LFLzWUjTRJ7oU"; RedisUtil.set(openid, "20180920/1537413108683.jpg|20180920/1537413108633.jpg|"); String str = RedisUtil.get(openid); //RedisUtil.expire(RedisKeys.PERSONALINCOMETAX, 10*60*60*1000); System.out.println(str); String[] strs = str.split("\\|"); System.out.println(strs[0]); /*int i = RedisUtil.expire(RedisKeys.IMAGEACQUISITION, 0); System.out.println(i);*/ &#125;&#125;2.com.redis下配置文件redis.properties1234567891011max_active=100#\u6700\u5927\u7a7a\u95f2\u6570max_idle=40#\u6700\u5927\u7b49\u5f85\u65f6\u95f4max_waitmillis=3000#redis\u5730\u5740host=127.0.0.1#redis\u7aef\u53e3port=6379#redis\u5bc6\u7801password=xxx3.com.redis下配置文件log4j.properties12345678910# Global logging configurationlog4j.rootLogger=INFO, stdout# My logging configuration...log4j.logger.com.geong=INFO## Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n git克隆地址https://github.com/syxiaowanzi/redis-util.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>redis redis工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加上评论系统-Valine]]></title>
    <url>%2F2019%2F01%2F20%2FHexo%E5%8A%A0%E4%B8%8A%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-Valine%2F</url>
    <content type="text"><![CDATA[环境hexo v3.8.0 、NexT.Pisces v6.7.0、leancloud 步骤leadcloud官网注册账号登陆leadcloud官网 注册 创建应用 应用名称可以自定义 获取appid与appkey创建之后进入应用-设置-应用key 进入博客next主题配置文件中修改搜素valine找到一下内容，修改enable，粘贴id、key，重新打包文件valine:&nbsp;&nbsp;&nbsp;&nbsp;enable: true&nbsp;&nbsp;&nbsp;&nbsp;appid:&nbsp;&nbsp;&nbsp;&nbsp;appkey:&nbsp;&nbsp;&nbsp;&nbsp;notify: false&nbsp;&nbsp;&nbsp;&nbsp;verify: false&nbsp;&nbsp;&nbsp;&nbsp;placeholder: 说点什么…&nbsp;&nbsp;&nbsp;&nbsp;avatar: mm&nbsp;&nbsp;&nbsp;&nbsp;guest_info: nick,mail,link&nbsp;&nbsp;&nbsp;&nbsp;pageSize: 10&nbsp;&nbsp;&nbsp;&nbsp;visitor: false&nbsp;&nbsp;&nbsp;&nbsp;comment_count: true 刷新页面评论测试假如第一次不成功，等两分钟后重新测试 假如某一页面不想加评论在顶部添加comments: false，同样适用与标签与分类 参考地址https://blog.csdn.net/blue_zy/article/details/79071414]]></content>
      <categories>
        <category>hexo-next主题优化</category>
      </categories>
      <tags>
        <tag>hexo添加评论 hexo next主题添加评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet生成图片验证码]]></title>
    <url>%2F2019%2F01%2F19%2Fservlet%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[环境eclipse(2018-12 (4.10.0)),jdk1.8.0_191,tomcat7.0.62代码1.SafeCodeUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.common.utils.safecode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** 生成指定大小的图片验证码，返回 * 并将图片验证码存入session中 * session对象imageCode * @author admin */public class SafeCodeUtil &#123; public static final String RANDOMCODEKEY = "imageCode";//放到session中的key private Random random = new Random(); //private String randString = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//随机产生的字符串 private String randString = "23456789ABCDEFGHJKLMNPRSTWXY";//随机产生的字符串 private int width = 73;//图片宽 private int height = 28;//图片高 private int lineSize = 30;//干扰线数量 private int stringNum = 4;//随机产生字符数量 /* * 获得字体 */ private Font getFont()&#123; return new Font("Fixedsys",Font.CENTER_BASELINE,18); &#125; /* * 获得颜色 */ private Color getRandColor(int fc,int bc)&#123; if(fc &gt; 255) &#123; fc = 255; &#125; if(bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc-fc-16); int g = fc + random.nextInt(bc-fc-14); int b = fc + random.nextInt(bc-fc-18); return new Color(r,g,b); &#125; /** * 生成随机图片 */ public void getRandcode(HttpServletRequest request, HttpServletResponse response) &#123; HttpSession session = request.getSession(); //BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR); Graphics g = image.getGraphics();//产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作 g.fillRect(0, 0, width, height); g.setFont(new Font("Times New Roman",Font.ROMAN_BASELINE,18)); g.setColor(getRandColor(110, 133)); //绘制干扰线 for(int i=0;i&lt;=lineSize;i++)&#123; drowLine(g); &#125; //绘制随机字符 String randomString = ""; for(int i=1;i&lt;=stringNum;i++)&#123; randomString=drowString(g,randomString,i); &#125; session.removeAttribute(RANDOMCODEKEY); session.setAttribute(RANDOMCODEKEY, randomString); g.dispose(); try &#123; ImageIO.write(image, "JPEG", response.getOutputStream());//将内存中的图片通过流动形式输出到客户端 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /* * 绘制字符串 */ private String drowString(Graphics g,String randomString,int i)&#123; g.setFont(getFont()); g.setColor(new Color(random.nextInt(101),random.nextInt(111),random.nextInt(121))); String rand = String.valueOf(getRandomString(random.nextInt(randString.length()))); randomString +=rand; g.translate(random.nextInt(3), random.nextInt(3)); g.drawString(rand, 13*i, 16); return randomString; &#125; /* * 绘制干扰线 */ private void drowLine(Graphics g)&#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(13); int yl = random.nextInt(15); g.drawLine(x, y, x+xl, y+yl); &#125; /* * 获取随机的字符 */ public String getRandomString(int num)&#123; return String.valueOf(randString.charAt(num)); &#125;&#125;2.SafeCode.java123456789101112131415161718192021222324package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/**生成验证码**/public class SafeCode extends HttpServlet &#123; private static final long SERIAL_VERSION_UID = 1L; @Override public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType("image/jpeg");// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader("Pragma", "No-cache");// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader("Cache-Control", "no-cache"); response.setDateHeader("Expire", 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;3.GenerateImageCode.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.common.utils.safecode.SafeCodeUtil;/** * @author wangming * 生成随机验证码 * Servlet implementation class GenerateImageCode */@WebServlet("/GenerateImageCode")public class GenerateImageCode extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public GenerateImageCode() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doPost(request, response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType("image/jpeg");// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader("Pragma", "No-cache");// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader("Cache-Control", "no-cache"); response.setDateHeader("Expire", 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;4.web.xml内webapps标签添加如下代码12345678&lt;servlet&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;servlet-class&gt;com.common.utils.safecode.GenerateImageCode&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;url-pattern&gt;/SafeCode&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;访问路径与结果http://localhost:8888/servletImgVerificationr/SafeCode，结果如下：克隆地址:https://github.com/syxiaowanzi/servlet-utils.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>验证码 图片验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署与上传github]]></title>
    <url>%2F2019%2F01%2F19%2Fhexo%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%B8%8A%E4%BC%A0github%2F</url>
    <content type="text"><![CDATA[环境winds10,github账户 搭建nodejs安装（我的版本v.10.15.0） 安装git与git客户端安装hexo,可以随便选择文件夹npm install -g hexo-cli hexo初始化与启动hexo init //初始化hexo generate //生成静态页面可以简写成 hexo ghexo server //启动可以简写成 hexo s 默认端口4000 访问本地即可看到一个helloworldhttp://localhost:4000 安装部署到github插件依赖，在站点根目录执行npm install hexo-deployer-git –save github上创建空博客创建新的仓库这里注意例如图中syxiaowanzi.github.io中syxiaowanzi必须是拥有者https://syxiaowanzi.github.io 本地hexo关联github上的博客hexo目录下_config.yml文件最下面添加 deploy: &nbsp;&nbsp;&nbsp;&nbsp;type: git &nbsp;&nbsp;&nbsp;&nbsp;repo: https://github.com/syxiaowanzi/syxiaowanzi.github.io.git &nbsp;&nbsp;&nbsp;&nbsp;branch: master 生成rsakeyssh-keygen -t rsa -C &quot;your github email” 默认会在C:\Users\yourPC.rsa生成连个文件id_rsa.pub与id_rsa 打开id_rsa.pub文件复制内容放到我们当前博客的仓库中 本地上传githubhexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 访问你的github博客即可看到helloworld优化博客我们可以选择多种优化主题，优化菜单等参考链接：https://blog.csdn.net/qq_32454537/article/details/79482896https://www.jianshu.com/p/efbeddc5eb19https://www.jianshu.com/p/56d99a3049a5]]></content>
      <categories>
        <category>hexo部署</category>
      </categories>
      <tags>
        <tag>hexo部署 hexo上传github</tag>
      </tags>
  </entry>
</search>
