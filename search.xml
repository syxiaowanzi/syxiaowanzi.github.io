<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java发送邮件]]></title>
    <url>%2F2019%2F01%2F22%2Fjava%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[环境jdk1.8activation.jarjavax.mail-1.6.2.jarlog4j-1.2.12.jarcommons-logging-1.1.1.jar 配置开启服务以qq邮箱为例，开启POP3/SMTP-IMAP/SMTP服务邮箱-设置-账户生成授权码之后一定要记住，代码中会用到 代码com.email.util下EmailUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177package com.email.util;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.*;import org.apache.log4j.Logger;import java.io.File;import java.util.Properties;/** * 封装Email相关的操作 */public final class EmailUtil &#123; private static Logger logger = Logger.getLogger(EmailUtil.class); private Properties properties = new Properties(); /** * Message对象将存储我们实际发送的电子邮件信息， */ private MimeMessage message; /** * Session类代表JavaMail中的一个邮件会话。 */ private Session session; private Transport transport; private String mailHost = &quot;&quot;; private int port = 465; private boolean auth = false; private String sender_username = &quot;&quot;; private String sender_password = &quot;&quot;; /** * 初始化方法 */ public EmailUtil(boolean debug) &#123; this.mailHost = EmailPropertiesUtil.getProperty(&quot;mail.smtp.host&quot;); this.port = Integer.valueOf(EmailPropertiesUtil.getProperty(&quot;mail.smtp.port&quot;)); this.auth = Boolean.parseBoolean(EmailPropertiesUtil.getProperty(&quot;mail.smtp.auth&quot;)); this.sender_username = EmailPropertiesUtil.getProperty(&quot;mail.sender.username&quot;); this.sender_password = EmailPropertiesUtil.getProperty(&quot;mail.sender.password&quot;); properties.put(&quot;mail.smtp.host&quot;, mailHost); properties.put(&quot;mail.smtp.auth&quot;, auth); properties.put(&quot;mail.smtp.port&quot;, String.valueOf(port)); properties.put(&quot;mail.sender.username&quot;, sender_username); properties.put(&quot;mail.sender.password&quot;, sender_password); properties.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;); session = Session.getInstance(properties); session.setDebug(debug);//开启后有调试信息 message = new MimeMessage(session); &#125; /** * 发送邮件 * * @param subject 邮件主题 * @param sendHtml 邮件内容 * @param receiveUser 收件人地址 */ public void doSendHtmlEmail(String subject, String sendHtml, String receiveUser) &#123; try &#123; // 发件人 InternetAddress from = new InternetAddress(sender_username); // 下面这个是设置发送人的Nick name //InternetAddress from = new InternetAddress(MimeUtility.encodeWord(&quot;幻影&quot;) + &quot; &lt;&quot; + sender_username + &quot;&gt;&quot;); message.setFrom(from); // 收件人 InternetAddress to = new InternetAddress(receiveUser); message.setRecipient(Message.RecipientType.TO, to);//还可以有CC、BCC // 邮件主题 message.setSubject(subject); String content = sendHtml.toString(); // 邮件内容,也可以使纯文本&quot;text/plain&quot; message.setContent(content, &quot;text/html;charset=UTF-8&quot;); // 保存邮件 message.saveChanges(); transport = session.getTransport(&quot;smtp&quot;); // smtp验证，就是你用来发邮件的邮箱用户名密码 logger.info(&quot;授权码:&quot;+sender_password); transport.connect(mailHost, port, sender_username, sender_password); // 发送 transport.sendMessage(message, message.getAllRecipients()); //System.out.println(&quot;send success!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (transport != null) &#123; try &#123; transport.close(); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 发送邮件 * * @param subject 邮件主题 * @param sendHtml 邮件内容 * @param receiveUser 收件人地址 * @param attachment 附件 */ public void doSendHtmlEmail(String subject, String sendHtml, String receiveUser, File attachment) &#123; try &#123; // 发件人 InternetAddress from = new InternetAddress(sender_username); message.setFrom(from); // 收件人 InternetAddress to = new InternetAddress(receiveUser); message.setRecipient(Message.RecipientType.TO, to); // 邮件主题 message.setSubject(subject); // 向multipart对象中添加邮件的各个部分内容，包括文本内容和附件 Multipart multipart = new MimeMultipart(); // 添加邮件正文 BodyPart contentPart = new MimeBodyPart(); contentPart.setContent(sendHtml, &quot;text/html;charset=UTF-8&quot;); multipart.addBodyPart(contentPart); // 添加附件的内容 if (attachment != null) &#123; BodyPart attachmentBodyPart = new MimeBodyPart(); DataSource source = new FileDataSource(attachment); attachmentBodyPart.setDataHandler(new DataHandler(source)); // 网上流传的解决文件名乱码的方法，其实用MimeUtility.encodeWord就可以很方便的搞定 // 这里很重要，通过下面的Base64编码的转换可以保证你的中文附件标题名在发送时不会变成乱码 //sun.misc.BASE64Encoder enc = new sun.misc.BASE64Encoder(); //messageBodyPart.setFileName(&quot;=?GBK?B?&quot; + enc.encode(attachment.getName().getBytes()) + &quot;?=&quot;); //MimeUtility.encodeWord可以避免文件名乱码 attachmentBodyPart.setFileName(MimeUtility.encodeWord(attachment.getName())); multipart.addBodyPart(attachmentBodyPart); &#125; // 将multipart对象放到message中 message.setContent(multipart); // 保存邮件 message.saveChanges(); transport = session.getTransport(&quot;smtp&quot;); // smtp验证，就是你用来发邮件的邮箱用户名密码 transport.connect(mailHost, port, sender_username, sender_password); // 发送 transport.sendMessage(message, message.getAllRecipients()); logger.info(&quot;send success!&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (transport != null) &#123; try &#123; transport.close(); &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; EmailUtil eu = new EmailUtil(true); eu.doSendHtmlEmail(&quot;ceshi&quot;, &quot;这是一个测试邮件&quot;, &quot;himingwang@126.com&quot;); &#125;&#125; com.email.util下EmailPropertiesUtil.java123456789101112131415161718192021222324252627282930package com.email.util;import java.io.IOException;import java.util.Properties;/** * @author wangming * @version * 读取获取配置文件相关信息 * */public class EmailPropertiesUtil &#123; private static Properties p = System.getProperties(); private static EmailPropertiesUtil propertiesUtil = null; private EmailPropertiesUtil()&#123; try &#123; p.load(EmailPropertiesUtil.class.getResourceAsStream(&quot;email.properties&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String getProperty(String key)&#123; if(propertiesUtil == null)&#123; propertiesUtil = new EmailPropertiesUtil(); &#125; return p.getProperty(key); &#125; public static void clear()&#123; p.clear(); &#125;&#125; com.email.util下email.properties12345mail.smtp.host=smtp.qq.commail.smtp.port=465mail.smtp.auth=truemail.sender.username=账户地址mail.sender.password=16位授权码 src下log4j.properties123456log4j.logger.com.opslab.util = ERRORlog4j.rootLogger = ERROR , stdoutlog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern =%d&#123;yyyy-MM-dd HH:mm:ss&#125; %5p [%c:%L] - %m%n 成功结果 git克隆地址https://github.com/syxiaowanzi/send-mail-util.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java发送邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字段校验工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%AD%97%E6%AE%B5%E6%A0%A1%E9%AA%8C%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述判断传入的字符串 是否符合特定的格式（非空 、手机号、验证固定电话、日期、邮箱、身份证号、姓名、验证英文名、邮编、验证出生日期、数字、小数点后两位的数字 、护照、企业姓名、企业证件号、台湾居民来往大陆通行证,港澳同胞回乡证、校验军官证、校验出生证明、校验港澳台居民居住证） 代码FieldValidationUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491package com.common.utils.register;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;import java.util.GregorianCalendar;import java.util.Hashtable;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * 判断 传入的字符串 是否符合特定的格式 * * @author 王明 * @date 2018-11-18 * */public class FieldValidationUtil &#123; /** * 根据验证类型 判断传入的字符串是否符合规则 * @author wangming * * 0 非空 * 1 手机号 * 2 验证固定电话 * 3 日期(支持 yyyy-MM-dd和yyyyMMdd) * 4 邮箱 * 4 身份证号 * 6 姓名 * 7 验证英文名 * 8 邮编 * 9 验证出生日期 * 10 数字 * 11 小数点后两位的数字 * 12 护照 * 13 企业姓名 * 14 企业证件号 * 15 台湾居民来往大陆通行证,港澳同胞回乡证 * 16 校验军官证 * 17 校验出生证明 * 18 校验港澳台居民居住证 * @return boolean 正确返回 true 否则 false */ public static boolean vailStringByType(int authType,String value)&#123; switch(authType)&#123; // 验证非空 case 0:&#123; if(null==value)&#123; return false; &#125; else&#123; if(&quot;&quot;.equals(value.trim()))&#123; return false; &#125;else&#123; return true; &#125; &#125; &#125; // 验证手机号 case 1:&#123; Pattern p = null; Matcher m = null; p = Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;mobile&quot;)); // 验证手机号 m = p.matcher(value); boolean b = m.matches(); return b; &#125; //验证固定电话 case 2:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;tel&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证日期 case 3:&#123; value=value.replaceAll(&quot;/&quot;,&quot;&quot;).replaceAll(&quot;-&quot;,&quot;&quot;); if(value!=null&amp;&amp;!&quot;&quot;.equals(value.trim()) &amp;&amp; value.length()==8)&#123; SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//小写的mm表示的是分钟 try &#123; sdf2.setLenient(false); sdf2.parse(value); return true; &#125; catch (ParseException e1) &#123; e1.printStackTrace(); return false; &#125; &#125;else&#123; return false; &#125; &#125; // 验证 邮箱 case 4:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;email&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证 身份证号 case 5:&#123; boolean b = vailIdCardNum(value); return b; &#125; // 验证姓名类型 case 6:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;name&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //验证英文名 case 7:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;ename&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //邮编 case 8:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;postCode&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证出生日期 case 9:&#123; value=value.replaceAll(&quot;/&quot;,&quot;&quot;).replaceAll(&quot;-&quot;,&quot;&quot;); if(value!=null&amp;&amp;!&quot;&quot;.equals(value.trim()) &amp;&amp; value.length()==8)&#123; SimpleDateFormat sdf2=new SimpleDateFormat(&quot;yyyyMMdd&quot;);//小写的mm表示的是分钟 SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);//小写的mm表示的是分钟 try &#123; sdf2.setLenient(false); sdf2.parse(value); String strYear = value.substring(0, 4);// 年份 String strMonth = value.substring(4, 6);// 月份 String strDay = value.substring(6, 8);// 月份 if (isDataFormat(strYear + &quot;-&quot; + strMonth + &quot;-&quot; + strDay) == false) &#123; return false; &#125; GregorianCalendar gc = new GregorianCalendar(); if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; 200 || (gc.getTime().getTime() - sdf.parse( strYear + &quot;-&quot; + strMonth + &quot;-&quot; + strDay).getTime()) &lt; 0) &#123; return false; &#125; if (Integer.parseInt(strMonth) &gt; 12 || Integer.parseInt(strMonth) == 0) &#123; return false; &#125; if (Integer.parseInt(strDay) &gt; 31 || Integer.parseInt(strDay) == 0) &#123; return false; &#125; // =====================(end)===================== return true; &#125; catch (ParseException e1) &#123; e1.printStackTrace(); return false; &#125; &#125;else&#123; return false; &#125; &#125; // 验证 数字 case 10:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;num&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //小数点后两位的数字 case 11:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;floatCheck&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; // 验证 护照 case 12:&#123; boolean b = checkPassportNumber(value); return b; &#125; //企业姓名 case 13:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;firmName&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //企业证件号 case 14:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;idCardNumber&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //台湾居民来往大陆通行证,港澳同胞回乡证 case 15:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;chinaOtherCard&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验军官证 case 16:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;officerNumber&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验出生证明 case 17:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;birthCard&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //校验港澳台居民居住证 case 18:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;gatNumber&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; //小数点后两位的数字 case 19:&#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;salryCheck&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; default:&#123; return false; &#125; &#125; &#125; /** * 验证身份证号 * @param IDStr * @return * @throws NumberFormatException * @throws ParseException */ public static boolean vailIdCardNum(String IDStr)&#123; try &#123; if(IDStr==null)&#123; return false; &#125;else&#123; IDStr = IDStr.toLowerCase(); &#125; String[] ValCodeArr = &#123; &quot;1&quot;, &quot;0&quot;, &quot;x&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot; &#125;; String[] Wi = &#123; &quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot;, &quot;1&quot;, &quot;6&quot;, &quot;3&quot;, &quot;7&quot;, &quot;9&quot;, &quot;10&quot;, &quot;5&quot;, &quot;8&quot;, &quot;4&quot;, &quot;2&quot; &#125;; String Ai = &quot;&quot;; // ================ 号码的长度 15位或18位 ================ if (IDStr.length() != 15 &amp;&amp; IDStr.length() != 18) &#123; return false; &#125; // ================ 数字 除最后以为都为数字 ================ if (IDStr.length() == 18) &#123; Ai = IDStr.substring(0, 17); &#125; else if (IDStr.length() == 15) &#123; Ai = IDStr.substring(0, 6) + &quot;19&quot; + IDStr.substring(6, 15); &#125; if (vailStringByType(8,Ai) == false) &#123; return false; &#125; // =======================(end)======================== // ================ 出生年月是否有效 ================ String strYear = Ai.substring(6, 10);// 年份 String strMonth = Ai.substring(10, 12);// 月份 String strDay = Ai.substring(12, 14);// 月份 if (isDataFormat(strYear + &quot;-&quot; + strMonth + &quot;-&quot; + strDay) == false) &#123; return false; &#125; GregorianCalendar gc = new GregorianCalendar(); SimpleDateFormat s = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); if ((gc.get(Calendar.YEAR) - Integer.parseInt(strYear)) &gt; 200 || (gc.getTime().getTime() - s.parse( strYear + &quot;-&quot; + strMonth + &quot;-&quot; + strDay).getTime()) &lt; 0) &#123; return false; &#125; if (Integer.parseInt(strMonth) &gt; 12 || Integer.parseInt(strMonth) == 0) &#123; return false; &#125; if (Integer.parseInt(strDay) &gt; 31 || Integer.parseInt(strDay) == 0) &#123; return false; &#125; // =====================(end)===================== // ================ 地区码时候有效 ================ Hashtable&lt;String, String&gt; h = GetAreaCode(); if (h.get(Ai.substring(0, 2)) == null) &#123; return false; &#125; // ============================================== // ================ 判断最后一位的值 ================ int TotalmulAiWi = 0; for (int i = 0; i &lt; 17; i++) &#123; TotalmulAiWi = TotalmulAiWi + Integer.parseInt(String.valueOf(Ai.charAt(i))) * Integer.parseInt(Wi[i]); &#125; int modValue = TotalmulAiWi % 11; String strVerifyCode = ValCodeArr[modValue]; Ai = Ai + strVerifyCode; if (IDStr.length() == 18) &#123; if (!Ai.equals(IDStr)) &#123; return false; &#125; &#125; else &#123; return true; &#125; // =====================(end)===================== return true; &#125; catch (NumberFormatException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return false; &#125; /** * 功能：设置地区编码 * @return Hashtable 对象 */ private static Hashtable&lt;String, String&gt; GetAreaCode() &#123; Hashtable&lt;String, String&gt; hashtable = new Hashtable&lt;String, String&gt;(); hashtable.put(&quot;11&quot;, &quot;北京&quot;); hashtable.put(&quot;12&quot;, &quot;天津&quot;); hashtable.put(&quot;13&quot;, &quot;河北&quot;); hashtable.put(&quot;14&quot;, &quot;山西&quot;); hashtable.put(&quot;15&quot;, &quot;内蒙古&quot;); hashtable.put(&quot;21&quot;, &quot;辽宁&quot;); hashtable.put(&quot;22&quot;, &quot;吉林&quot;); hashtable.put(&quot;23&quot;, &quot;黑龙江&quot;); hashtable.put(&quot;31&quot;, &quot;上海&quot;); hashtable.put(&quot;32&quot;, &quot;江苏&quot;); hashtable.put(&quot;33&quot;, &quot;浙江&quot;); hashtable.put(&quot;34&quot;, &quot;安徽&quot;); hashtable.put(&quot;35&quot;, &quot;福建&quot;); hashtable.put(&quot;36&quot;, &quot;江西&quot;); hashtable.put(&quot;37&quot;, &quot;山东&quot;); hashtable.put(&quot;41&quot;, &quot;河南&quot;); hashtable.put(&quot;42&quot;, &quot;湖北&quot;); hashtable.put(&quot;43&quot;, &quot;湖南&quot;); hashtable.put(&quot;44&quot;, &quot;广东&quot;); hashtable.put(&quot;45&quot;, &quot;广西&quot;); hashtable.put(&quot;46&quot;, &quot;海南&quot;); hashtable.put(&quot;50&quot;, &quot;重庆&quot;); hashtable.put(&quot;51&quot;, &quot;四川&quot;); hashtable.put(&quot;52&quot;, &quot;贵州&quot;); hashtable.put(&quot;53&quot;, &quot;云南&quot;); hashtable.put(&quot;54&quot;, &quot;西藏&quot;); hashtable.put(&quot;61&quot;, &quot;陕西&quot;); hashtable.put(&quot;62&quot;, &quot;甘肃&quot;); hashtable.put(&quot;63&quot;, &quot;青海&quot;); hashtable.put(&quot;64&quot;, &quot;宁夏&quot;); hashtable.put(&quot;65&quot;, &quot;新疆&quot;); hashtable.put(&quot;71&quot;, &quot;台湾&quot;); hashtable.put(&quot;81&quot;, &quot;香港&quot;); hashtable.put(&quot;82&quot;, &quot;澳门&quot;); hashtable.put(&quot;91&quot;, &quot;国外&quot;); return hashtable; &#125; /** * @desc 校验护照 * @param value * @return boolean */ private static boolean checkPassportNumber(String value) &#123; Pattern reg= Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;passportNumber&quot;)); Matcher m = reg.matcher(value); boolean b = m.matches(); return b; &#125; /**验证日期字符串是否是YYYY-MM-DD格式 * @param str * @return */ private static boolean isDataFormat(String str)&#123; boolean flag=false; String regxStr=ValidationPropertiesUtil.getProperty(&quot;dateFormat&quot;); Pattern pattern1=Pattern.compile(regxStr); Matcher isNo=pattern1.matcher(str); if(isNo.matches())&#123; flag=true; &#125; return flag; &#125; //验证出生日期是否在当前日期之前 public static boolean validationBirthDate(Date birthDate)&#123; Date date =new Date(); int number=date.compareTo(birthDate); if(number&gt;0)&#123; return true; &#125;else&#123; return false; &#125; &#125; /** * * @param str 字符串 * @param flag 1 过滤全部字符串 、 2 过滤收尾字符串 * @return */ public static String trim(String str,Integer flag)&#123; if(flag == 1)&#123; return str.replaceAll(&quot; &quot;, &quot;&quot;); &#125;else if(flag == 2)&#123; return str.trim(); &#125; return str; &#125; /** * 判断字符串中是否包含中文 * @param str * 待校验字符串 * @return 是否为中文 * @warn 不能校验是否为中文标点符号 */ public static boolean isContainChinese(String str) &#123; Pattern p = Pattern.compile(ValidationPropertiesUtil.getProperty(&quot;is_chinese&quot;)); Matcher m = p.matcher(str); if (m.find()) &#123; return true; &#125; return false; &#125; /** * 过滤后空格的字符串 * @param str * @return */ public static String getAfterTrimStr(String str)&#123; if(str!=null&amp;&amp;!&quot;&quot;.equals(str))&#123; if(isContainChinese(str))&#123; return trim(str,1); &#125;else&#123; return trim(str,2); &#125; &#125; return &quot;&quot;; &#125; /** * 身份证号的特殊字符转化 * @param str * @return */ public static String getIdCardNumberStr(String str)&#123; if(str!=null&amp;&amp;!&quot;&quot;.equals(str))&#123; return str.toUpperCase().replace(&quot;×&quot;, &quot;X&quot;).replace(&quot;x&quot;, &quot;X&quot;); &#125; return &quot;&quot;; &#125; /** * 证件有效期判断转换 */ public static String cardDate(String idStartDate , String idEndDate,String isLongterm)&#123; String cardDateString=&quot;&quot;; if(idStartDate==&quot;&quot; || idStartDate==null)&#123; return cardDateString; &#125; if(&quot;1&quot;.equals(isLongterm) || &quot;&quot;.equals(idEndDate) || idEndDate == null) &#123; cardDateString = idStartDate + &quot;-&quot; +&quot;长期&quot;; &#125;else &#123; cardDateString = idStartDate + &quot;-&quot; + idEndDate; &#125; return cardDateString; &#125; &#125; ValidationPropertiesUtil.java123456789101112131415161718192021222324252627282930package com.common.utils.register;import java.io.IOException;import java.util.Properties;/** * @author wangming * @version * 读取获取配置文件相关信息 * */public class ValidationPropertiesUtil &#123; private static Properties p = System.getProperties(); private static ValidationPropertiesUtil propertiesUtil = null; private ValidationPropertiesUtil()&#123; try &#123; p.load(ValidationPropertiesUtil.class.getResourceAsStream(&quot;validation.properties&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static String getProperty(String key)&#123; if(propertiesUtil == null)&#123; propertiesUtil = new ValidationPropertiesUtil(); &#125; return p.getProperty(key); &#125; public static void clear()&#123; p.clear(); &#125;&#125; validation.properties1234567891011121314151617181920212223242526272829303132#手机号码校验规则mobile = ^(13|14|15|17|18|19|16)[0-9]&#123;9&#125;$#验证固定电话tel = ^(0[1-9][0-9])-\d&#123;8&#125;$|^(0[1-9]&#123;3&#125;-(\d&#123;7,8&#125;))$#邮件检验email = ^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.([a-zA-Z0-9_-])+)+$#姓名name = ^[\u0391-\uffe5]&#123;2,20&#125;$|^[a-zA-Z\\s]&#123;2,20&#125;$#name = ^[\\u4e00-\\u9fa5]&#123;1&#125;[\\u4e00-\\u9fa5\.·。]&#123;0,20&#125;[\\u4e00-\\u9fa5]&#123;1&#125;$)|([a-zA-Z]&#123;1&#125;[a-zA-Z\\-]&#123;0,20&#125;[a-zA-Z]&#123;1&#125;$#英文姓名ename:^[a-zA-Z \s]&#123;2,20&#125;$#邮编postCode=^[0-9]\\d&#123;5&#125;$#数字num = ^[0-9]*$#小数点后两位数字floatCheck = ^[0-9]+(.[0-9]&#123;1,2&#125;)?$salryCheck = \\d\\.\\d*|[1-9]\\d*|\\d*\\.\\d*|\\d#校验护照passportNumber = ^[a-zA-Z0-9]&#123;3,16&#125;$#企业姓名firmName=^([A-Za-z]|[\u4E00-\u9FA5]|\\\\uFF08|\\\\uFF09)&#123;2,30&#125;$#企业证件号idCardNumber=^[0-9a-zA-Z]+$#台湾居民来往大陆通行证,港澳同胞回乡证chinaOtherCard=^[\\\d\\\D]&#123;8,18&#125;$#校验军官证officerNumber=^[a-zA-Z0-9-\u4e00-\u9fa5]&#123;10,18&#125;$#校验出生证明birthCard=^[0-9a-zA-Z]&#123;1,18&#125;$#校验港澳台居民居住证gatNumber=^(810000|820000|830000)[A-Z0-9]&#123;12&#125;$ Test.java123456package com.common.utils.register;public class Test &#123; public static void main(String[] args) &#123; System.out.println(FieldValidationUtil.vailStringByType(6, &quot;哈哈哈&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java字段校验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成随机数工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述生成制定范围内的随机数、返回固定长度的数字、返回一个定长的随机字符串(只包含大小写字母、数字)、返回一个定长的随机纯字母字符串(只包含大小写字母)、返回一个定长的随机纯大写字母字符串(只包含大小写字母)、返回一个UUID等等。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299package com.common.utils.random;import java.util.*;public final class RandomUtil &#123; public static final String ALLCHAR = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; public static final String LETTERCHAR = &quot;abcdefghijkllmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; public static final String NUMBERCHAR = &quot;0123456789&quot;; /** * 生成制定范围内的随机数 * * @param scopeMin * @param scoeMax * @return */ public static int integer(int scopeMin, int scoeMax) &#123; Random random = new Random(); return (random.nextInt(scoeMax) % (scoeMax - scopeMin + 1) + scopeMin); &#125; /** * 返回固定长度的数字 * * @param length * @return */ public static String number(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(NUMBERCHAR.charAt(random.nextInt(NUMBERCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机字符串(只包含大小写字母、数字) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String String(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(ALLCHAR.charAt(random.nextInt(ALLCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机纯字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String MixString(int length) &#123; StringBuffer sb = new StringBuffer(); Random random = new Random(); for (int i = 0; i &lt; length; i++) &#123; sb.append(ALLCHAR.charAt(random.nextInt(LETTERCHAR.length()))); &#125; return sb.toString(); &#125; /** * 返回一个定长的随机纯大写字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String LowerString(int length) &#123; return MixString(length).toLowerCase(); &#125; /** * 返回一个定长的随机纯小写字母字符串(只包含大小写字母) * * @param length 随机字符串长度 * @return 随机字符串 */ public static String UpperString(int length) &#123; return MixString(length).toUpperCase(); &#125; /** * 生成一个定长的纯0字符串 * * @param length 字符串长度 * @return 纯0字符串 */ public static String ZeroString(int length) &#123; StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; length; i++) &#123; sb.append(&apos;0&apos;); &#125; return sb.toString(); &#125; /** * 根据数字生成一个定长的字符串，长度不够前面补0 * * @param num 数字 * @param fixdlenth 字符串长度 * @return 定长的字符串 */ public static String toFixdLengthString(long num, int fixdlenth) &#123; StringBuffer sb = new StringBuffer(); String strNum = String.valueOf(num); if (fixdlenth - strNum.length() &gt;= 0) &#123; sb.append(ZeroString(fixdlenth - strNum.length())); &#125; else &#123; throw new RuntimeException(&quot;将数字&quot; + num + &quot;转化为长度为&quot; + fixdlenth + &quot;的字符串发生异常！&quot;); &#125; sb.append(strNum); return sb.toString(); &#125; /** * 根据数字生成一个定长的字符串，长度不够前面补0 * * @param num 数字 * @param fixdlenth 字符串长度 * @return 定长的字符串 */ public static String toFixdLengthString(int num, int fixdlenth) &#123; StringBuffer sb = new StringBuffer(); String strNum = String.valueOf(num); if (fixdlenth - strNum.length() &gt;= 0) &#123; sb.append(ZeroString(fixdlenth - strNum.length())); &#125; else &#123; throw new RuntimeException(&quot;将数字&quot; + num + &quot;转化为长度为&quot; + fixdlenth + &quot;的字符串发生异常！&quot;); &#125; sb.append(strNum); return sb.toString(); &#125; /** * 每次生成的len位数都不相同 * * @param param * @return 定长的数字 */ public static int getNotSimple(int[] param, int len) &#123; Random rand = new Random(); for (int i = param.length; i &gt; 1; i--) &#123; int index = rand.nextInt(i); int tmp = param[index]; param[index] = param[i - 1]; param[i - 1] = tmp; &#125; int result = 0; for (int i = 0; i &lt; len; i++) &#123; result = result * 10 + param[i]; &#125; return result; &#125; /** * 从指定的数组中随机数组中的某个元素 */ public static &lt;T&gt; T randomItem(T[] param) &#123; int index = integer(0, param.length); return param[index]; &#125; /** * 实现一个简单的字符串乘法 * @param str * @param multiplication * @return */ private static String strMultiplication(String str,int multiplication)&#123; StringBuffer buffer = new StringBuffer(); for (int i = 0; i &lt; multiplication; i++) &#123; buffer.append(str); &#125; return buffer.toString(); &#125; /** * 从指定的数组中按照指定比例返回指定的随机元素 * @param param * @param percentum * @param &lt;T&gt; * @return */ public static &lt;T&gt; T randomItem(T[] param,double[] percentum)&#123; int length = percentum.length; Integer[] ints = doubleBitCount(percentum); int max = Collections.max(Arrays.asList(ints)); int[] arr = new int[length]; int sum = 0; Map map = new HashMap(length); int multiple = Integer.parseInt(&quot;1&quot;+strMultiplication(&quot;0&quot;,max)); for (int i = 0; i &lt; length; i++) &#123; int temp = (int)(percentum[i] * multiple); arr[i] = temp; if(i == 0)&#123; map.put(i,new int[]&#123;1,temp&#125;); &#125;else&#123; map.put(i,new int[]&#123;sum,sum+temp&#125;); &#125; sum += temp; &#125; int indexSum = integer(1,sum); int index =-1; for (int i = 0; i &lt; length; i++) &#123; int[] scope = (int[]) map.get(i); if(indexSum ==1 )&#123; index = 0; break; &#125; if(indexSum &gt; scope[0] &amp;&amp; indexSum &lt;= scope[1])&#123; index =i; break; &#125; &#125; if(index == -1)&#123; throw new RuntimeException(&quot;随机失败&quot;); &#125;else&#123; return param[index]; &#125; &#125; /** * 返回一个UUID * * @return 小写的UUID */ public static String uuid() &#123; UUID uuid = UUID.randomUUID(); String s = uuid.toString(); return s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24); &#125; /** * 返回一个UUID * * @return 大写的UUID */ public static String UUID() &#123; UUID uuid = UUID.randomUUID(); String s = uuid.toString(); String temp = s.substring(0, 8) + s.substring(9, 13) + s.substring(14, 18) + s.substring(19, 23) + s.substring(24); return temp.toUpperCase(); &#125; /** * 返回一个有序列的uuid编码 * 前11位为时间(毫秒) * 中间4位为主机特征码 * 剩下的保证其唯一性 * * @return */ public static String squid() &#123; Long date = new Date().getTime(); String s = UUID.randomUUID().toString(); String str = Long.toHexString(date); String result = str + &quot;0001&quot; + s.substring(17, 18) + s.substring(19, 23) + s.substring(24); return result.toUpperCase(); &#125; /** * 获取一个double类型的数字的小数位有多长 * @param arr double类型的数组 * @return integer类型长度值 */ public static Integer[] doubleBitCount(double[] arr)&#123; Integer[] len = new Integer[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; len[i] = doueleBitCount(arr[i]); &#125; return len; &#125; /** * 获取一个double类型的数字的小数位有多长 * @param dd * @return */ public static int doueleBitCount(double dd)&#123; String temp = String.valueOf(dd); int i = temp.indexOf(&quot;.&quot;); if(i &gt; -1)&#123; return temp.length()-i -1; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java生成随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xml相关的工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fxml%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述读取xml数据返回string数据xml与map的相互转换 代码读取xml转换成string 12345678910111213141516171819202122232425262728293031package com.common.utils.xml;import java.io.File;import java.io.FileInputStream;import java.io.IOException;/** * 读取xml数据 * @author wangming * return String 类型数据 */public class ReadXmlFileToString &#123; public static String readXmlString(String filePath) &#123; String str=&quot;&quot;; File file = new File(filePath); try &#123; FileInputStream in = new FileInputStream(file); // size 为字串的长度 ，这里一次性读完 int size=in.available(); byte[] buffer=new byte[size]; in.read(buffer); in.close(); str=new String(buffer,&quot;UTF-8&quot;); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); return null; &#125; return str; &#125;&#125; xml与map的相互转换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.common.utils.xml;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.io.StringWriter;import java.util.HashMap;import java.util.Map;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.transform.OutputKeys;import javax.xml.transform.Transformer;import javax.xml.transform.TransformerFactory;import javax.xml.transform.dom.DOMSource;import javax.xml.transform.stream.StreamResult;import org.w3c.dom.Node;import org.w3c.dom.NodeList;/** * 微信开发所需工具类 * 注:该工具适用于一层xml格式,存在二级element时，不适用 * @author wangming * @see 转换的xml发送前需去换行符.replaceAll(&quot;\n|\r&quot;, &quot;&quot;) * @see 因微信接口在后期发展会增加返回字段，所以xml先转map再转obj * */public class XmlMapUtil &#123; /** * XML格式字符串转换为Map * * @param strXML XML字符串 * @return XML数据转换后的Map * @throws Exception */ public static Map&lt;String, String&gt; xmlToMap(String strXML) throws Exception &#123; try &#123; Map&lt;String, String&gt; data = new HashMap&lt;String, String&gt;(); DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder(); InputStream stream = new ByteArrayInputStream(strXML.getBytes(&quot;UTF-8&quot;)); org.w3c.dom.Document doc = documentBuilder.parse(stream); doc.getDocumentElement().normalize(); NodeList nodeList = doc.getDocumentElement().getChildNodes(); for (int idx = 0; idx &lt; nodeList.getLength(); ++idx) &#123; Node node = nodeList.item(idx); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; org.w3c.dom.Element element = (org.w3c.dom.Element) node; data.put(element.getNodeName(), element.getTextContent()); &#125; &#125; try &#123; stream.close(); &#125; catch (Exception ex) &#123; // do nothing &#125; return data; &#125; catch (Exception ex) &#123; throw ex; &#125; &#125; /** * 将Map转换为XML格式的字符串 * * @param data Map类型数据 * @return XML格式的字符串 * @throws Exception */ public static String mapToXml(Map&lt;String, String&gt; data) throws Exception &#123; DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilder= documentBuilderFactory.newDocumentBuilder(); org.w3c.dom.Document document = documentBuilder.newDocument(); org.w3c.dom.Element root = document.createElement(&quot;xml&quot;); document.appendChild(root); for (String key: data.keySet()) &#123; String value = data.get(key); if (value == null) &#123; value = &quot;&quot;; &#125; value = value.trim(); org.w3c.dom.Element filed = document.createElement(key); filed.appendChild(document.createTextNode(value)); root.appendChild(filed); &#125; TransformerFactory tf = TransformerFactory.newInstance(); Transformer transformer = tf.newTransformer(); DOMSource source = new DOMSource(document); transformer.setOutputProperty(OutputKeys.ENCODING, &quot;UTF-8&quot;); transformer.setOutputProperty(OutputKeys.INDENT, &quot;no&quot;); transformer.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, &quot;no&quot;); StringWriter writer = new StringWriter(); StreamResult result = new StreamResult(writer); transformer.transform(source, result); String output = writer.getBuffer().toString(); //.replaceAll(&quot;\n|\r&quot;, &quot;&quot;); try &#123; writer.close(); &#125; catch (Exception ex) &#123; &#125; return output; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>读取xml转换成string map转换成xml xml转换成map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述为空或者null、不为空、String转换成int、String转换成long、切分string成数组 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package com.common.utils.string;/** * 字符串工具类 * @author wangming * 1 isEmpty() 为空或者null * 2 isNotEmpty() 不为空 * 3 parseStringInt() String转换成int * 4 parseStringLong() String转换成long * 5 parseStringArray() 切分string成数组 */public class StringUtil &#123; /** * 判断是否为空字符串最优代码 * @param str * @return 如果为空，则返回true */ public static boolean isEmpty(String str)&#123; return str == null || str.trim().length() == 0; &#125; /** * 判断字符串是否非空 * @param str 如果不为空，则返回true * @return */ public static boolean isNotEmpty(String str)&#123; return !isEmpty(str); &#125; /** * 将String类型转换成int类型 * @param str * @return */ public static int parseStringInt(String str) &#123; return Integer.parseInt(str); &#125; /** * 将String类型数据转换成long类型 * @param str * @return */ public static long parseStringLong(String str) &#123; return Long.parseLong(str); &#125; /** * 根据规则将string转换成数组 * @param str 字符串 * @param regex 规则 * @return 数组 */ public static String[] parseStringArray(String str,String regex) &#123; String [] arr = str.split(regex); return arr; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java字符串工具类 java字符串转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数学工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[描述加减乘除四舍五入 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.common.utils.math;import java.math.BigDecimal;/** * 数学工具类 * 加减乘除四舍五入 * @author wangming * */public class Arith &#123; private static final int DEF_DIV_SCALE = 10; // 这个类不能实例化 private Arith() &#123; &#125; /** * 提供精确的加法运算。 * * @param v1 * 被加数 * @param v2 * 加数 * @return 两个参数的和 */ public static double add(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2).doubleValue(); &#125; /** * 提供精确的减法运算。 * * @param v1 * 被减数 * @param v2 * 减数 * @return 两个参数的差 */ public static double sub(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2).doubleValue(); &#125; /** * 提供精确的乘法运算。 * * @param v1 * 被乘数 * @param v2 * 乘数 * @return 两个参数的积 */ public static double mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2).doubleValue(); &#125; /** * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到 小数点以后10位，以后的数字四舍五入。 * * @param v1 * 被除数 * @param v2 * 除数 * @return 两个参数的商 */ public static double div(double v1, double v2) &#123; return div(v1, v2, DEF_DIV_SCALE); &#125; /** * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指 定精度，以后的数字四舍五入。 * * @param v1 * 被除数 * @param v2 * 除数 * @param scale * 表示表示需要精确到小数点以后几位。 * @return 两个参数的商 */ public static double div(double v1, double v2, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125; /** * 提供精确的小数位四舍五入处理。 * * @param v * 需要四舍五入的数字 * @param scale * 小数点后保留几位 * @return 四舍五入后的结果 */ public static double round(double v, int scale) &#123; if (scale &lt; 0) &#123; throw new IllegalArgumentException( &quot;The scale must be a positive integer or zero&quot;); &#125; BigDecimal b = new BigDecimal(Double.toString(v)); BigDecimal one = new BigDecimal(&quot;1&quot;); return b.divide(one, scale, BigDecimal.ROUND_HALF_UP).doubleValue(); &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java数学工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java加密工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java加密工具类包含AES、DES、Base32、Base64 AES代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.common.utils.encrypt;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.SecureRandom;import java.util.Scanner;import javax.crypto.BadPaddingException;import javax.crypto.Cipher;import javax.crypto.IllegalBlockSizeException;import javax.crypto.KeyGenerator;import javax.crypto.NoSuchPaddingException;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** * AES对称加密和解密 * @auth wangming */public class AESUtil &#123; public static String encodeRules = &quot;123456789&quot;; /** * 加密 * 1.构造密钥生成器 * 2.根据ecnodeRules规则初始化密钥生成器 * 3.产生密钥 * 4.创建和初始化密码器 * 5.内容加密 * 6.返回字符串 */ public static String AESEncode(String encodeRules,String content)&#123; try &#123; //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen = KeyGenerator.getInstance(&quot;AES&quot;); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key = keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw = original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key = new SecretKeySpec(raw, &quot;AES&quot;); //6.根据指定算法AES自成密码器 Cipher cipher = Cipher.getInstance(&quot;AES&quot;); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.ENCRYPT_MODE, key); //8.获取加密内容的字节数组(这里要设置为utf-8)不然内容中如果有中文和英文混合中文就会解密为乱码 byte [] byte_encode = content.getBytes(&quot;utf-8&quot;); //9.根据密码器的初始化方式--加密：将数据加密 byte [] byte_AES = cipher.doFinal(byte_encode); //10.将加密后的数据转换为字符串 //这里用Base64Encoder中会找不到包 //解决办法： //在项目的Build path中先移除JRE System Library，再添加库JRE System Library，重新编译后就一切正常了。 String AES_encode = new String(new BASE64Encoder().encode(byte_AES)); //11.将字符串返回 return AES_encode; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; //如果有错就返加nulll return null; &#125; /** * 解密 * 解密过程： * 1.同加密1-4步 * 2.将加密后的字符串反纺成byte[]数组 * 3.将加密内容解密 */ public static String AESDncode(String encodeRules,String content)&#123; try &#123; //1.构造密钥生成器，指定为AES算法,不区分大小写 KeyGenerator keygen = KeyGenerator.getInstance(&quot;AES&quot;); //2.根据ecnodeRules规则初始化密钥生成器 //生成一个128位的随机源,根据传入的字节数组 keygen.init(128, new SecureRandom(encodeRules.getBytes())); //3.产生原始对称密钥 SecretKey original_key = keygen.generateKey(); //4.获得原始对称密钥的字节数组 byte [] raw=original_key.getEncoded(); //5.根据字节数组生成AES密钥 SecretKey key = new SecretKeySpec(raw, &quot;AES&quot;); //6.根据指定算法AES自成密码器 Cipher cipher = Cipher.getInstance(&quot;AES&quot;); //7.初始化密码器，第一个参数为加密(Encrypt_mode)或者解密(Decrypt_mode)操作，第二个参数为使用的KEY cipher.init(Cipher.DECRYPT_MODE, key); //8.将加密并编码后的内容解码成字节数组 byte [] byte_content = new BASE64Decoder().decodeBuffer(content); /** * 解密 */ byte [] byte_decode = cipher.doFinal(byte_content); String AES_decode = new String(byte_decode,&quot;utf-8&quot;); return AES_decode; &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (NoSuchPaddingException e) &#123; e.printStackTrace(); &#125; catch (InvalidKeyException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (IllegalBlockSizeException e) &#123; e.printStackTrace(); &#125; catch (BadPaddingException e) &#123; e.printStackTrace(); &#125; //如果有错就返加nulll return null; &#125; public static void main(String[] args) &#123; AESUtil se = new AESUtil(); Scanner scanner = new Scanner(System.in); /** * 加密 */ System.out.println(&quot;使用AES对称加密，请输入加密的规则&quot;); String encodeRules = scanner.next(); System.out.println(&quot;请输入要加密的内容:&quot;); String content = scanner.next(); System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;加密后的密文是:&quot;+se.AESEncode(encodeRules, content)); /** * 解密 */ System.out.println(&quot;使用AES对称解密，请输入加密的规则：(须与加密相同)&quot;); encodeRules = scanner.next(); System.out.println(&quot;请输入要解密的内容（密文）:&quot;); content = scanner.next(); System.out.println(&quot;根据输入的规则&quot;+encodeRules+&quot;解密后的明文是:&quot;+se.AESDncode(encodeRules, content)); &#125;&#125; MD5代码 1234567891011121314151617181920212223242526272829303132333435363738394041package com.common.utils.encrypt;import java.nio.charset.Charset;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * 根据字符串md5加密 * 字符串长度小于1024*2 * @author wangming * */public class MD5Util &#123; private static final int MD5_LENGTH = 1024 * 2;//1024 * 2 - 512 public static String generateMD5(String plainText) &#123; try &#123; if(null == plainText || plainText.length() == 0) &#123; return null; &#125; plainText = (plainText.length() &gt; MD5_LENGTH)? plainText.substring(0, MD5_LENGTH) : plainText; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); byte[] bytes = plainText.getBytes(Charset.forName(&quot;UTF-8&quot;)); md.update(bytes); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(&quot;&quot;); for (int offset = 0, j = b.length; offset &lt; j; offset++) &#123; i = b[offset]; if (i &lt; 0) &#123; i += 256; &#125; if (i &lt; 16) &#123; buf.append(&quot;0&quot;); &#125; buf.append(Integer.toHexString(i)); &#125; return buf.toString().toLowerCase(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); return null; &#125; &#125; &#125; Base32代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package com.common.utils.encrypt;/** * Base32的编码和解码 */public final class Base32 &#123; private static final String ERR_CANONICAL = &quot;Invalid Base32 string&quot;; private static final char[] CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;.toCharArray(); private static final byte[] LOOKUP = &#123; 26, 27, 28, 29, 30, 31, -1, -1, -1, -1, -1, -1, -1, -1, // 0123456789:;&lt;=&gt;? -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // @ABCDEFGHIJKLMNO 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, // PQRSTUVWXYZ[\]^_ -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // `abcdefghijklmno 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25 // pqrstuvwxyz &#125;; /** * 使用Base32进行编码 * * @param bytes * @return */ public final static String encode(final byte[] bytes) &#123; StringBuilder base32 = new StringBuilder((bytes.length * 8 + 4) / 5); int currByte, digit, i = 0; while (i &lt; bytes.length) &#123; // STEP 0; insert new 5 bits, leave 3 bits currByte = bytes[i++] &amp; 255; base32.append(CHARS[currByte &gt;&gt; 3]); digit = (currByte &amp; 7) &lt;&lt; 2; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 3: insert 2 new bits, then 5 bits, leave 1 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 6)]); base32.append(CHARS[(currByte &gt;&gt; 1) &amp; 31]); digit = (currByte &amp; 1) &lt;&lt; 4; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 1: insert 4 new bits, leave 4 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 4)]); digit = (currByte &amp; 15) &lt;&lt; 1; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 4: insert 1 new bit, then 5 bits, leave 2 bits currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 7)]); base32.append(CHARS[(currByte &gt;&gt; 2) &amp; 31]); digit = (currByte &amp; 3) &lt;&lt; 3; if (i &gt;= bytes.length) &#123; base32.append(CHARS[digit]); break; &#125; // STEP 2: insert 3 new bits, then 5 bits, leave 0 bit currByte = bytes[i++] &amp; 255; base32.append(CHARS[digit | (currByte &gt;&gt; 5)]); base32.append(CHARS[currByte &amp; 31]); &#125; return base32.toString(); &#125; /** * 用Base32进行解码 * * @param base32 * @return * @throws IllegalArgumentException */ public final static String decode(final String base32) throws IllegalArgumentException &#123; switch (base32.length() % 8) &#123; case 1: case 3: case 6: throw new IllegalArgumentException(ERR_CANONICAL); &#125; byte[] bytes = new byte[base32.length() * 5 / 8]; int offset = 0, i = 0, lookup; byte nextByte, digit; while (i &lt; base32.length()) &#123; lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 0: leave 5 bits nextByte = (byte) (digit &lt;&lt; 3); lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 5: insert 3 bits, leave 2 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 2)); nextByte = (byte) ((digit &amp; 3) &lt;&lt; 6); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 2: leave 7 bits nextByte |= (byte) (digit &lt;&lt; 1); lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 7: insert 1 bit, leave 4 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 4)); nextByte = (byte) ((digit &amp; 15) &lt;&lt; 4); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 4: insert 4 bits, leave 1 bit bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 1)); nextByte = (byte) ((digit &amp; 1) &lt;&lt; 7); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 1: leave 6 bits nextByte |= (byte) (digit &lt;&lt; 2); lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 6: insert 2 bits, leave 3 bits bytes[offset++] = (byte) (nextByte | (digit &gt;&gt; 3)); nextByte = (byte) ((digit &amp; 7) &lt;&lt; 5); if (i &gt;= base32.length()) &#123; if (nextByte != (byte) 0) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; break; &#125; lookup = base32.charAt(i++) - &apos;2&apos;; if (lookup &lt; 0 || lookup &gt;= LOOKUP.length) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; digit = LOOKUP[lookup]; if (digit == -1) &#123; throw new IllegalArgumentException(ERR_CANONICAL); &#125; // STEP n = 3: insert 5 bits, leave 0 bit bytes[offset++] = (byte) (nextByte | digit); &#125; return new String(bytes); &#125;&#125; Base64代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297package com.common.utils.encrypt;import java.io.UnsupportedEncodingException;import java.util.Arrays;/** * Base64的编码和解码 */public final class Base64 &#123; private static final char[] CHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;.toCharArray(); private static final int[] INV = new int[256]; static &#123; Arrays.fill(INV, -1); for (int i = 0, iS = CHARS.length; i &lt; iS; i++) &#123; INV[CHARS[i]] = i; &#125; INV[&apos;=&apos;] = 0; &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;char[]&lt;/code&gt;. * * @param lineSeparator optional CRLF after 76 chars, unless EOF. */ public final static char[] encodeToChar(byte[] arr, boolean lineSeparator) &#123; int len = arr != null ? arr.length : 0; if (len == 0) &#123; return new char[0]; &#125; int evenlen = (len / 3) * 3; int cnt = ((len - 1) / 3 + 1) &lt;&lt; 2; int destLen = cnt + (lineSeparator ? (cnt - 1) / 76 &lt;&lt; 1 : 0); char[] dest = new char[destLen]; for (int s = 0, d = 0, cc = 0; s &lt; evenlen; ) &#123; int i = (arr[s++] &amp; 0xff) &lt;&lt; 16 | (arr[s++] &amp; 0xff) &lt;&lt; 8 | (arr[s++] &amp; 0xff); dest[d++] = CHARS[(i &gt;&gt;&gt; 18) &amp; 0x3f]; dest[d++] = CHARS[(i &gt;&gt;&gt; 12) &amp; 0x3f]; dest[d++] = CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[d++] = CHARS[i &amp; 0x3f]; if (lineSeparator &amp;&amp; (++cc == 19) &amp;&amp; (d &lt; (destLen - 2))) &#123; dest[d++] = &apos;\r&apos;; dest[d++] = &apos;\n&apos;; cc = 0; &#125; &#125; int left = len - evenlen; // 0 - 2. if (left &gt; 0) &#123; int i = ((arr[evenlen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((arr[len - 1] &amp; 0xff) &lt;&lt; 2) : 0); dest[destLen - 4] = CHARS[i &gt;&gt; 12]; dest[destLen - 3] = CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[destLen - 2] = left == 2 ? CHARS[i &amp; 0x3f] : &apos;=&apos;; dest[destLen - 1] = &apos;=&apos;; &#125; return dest; &#125; public final static byte[] encodeToByte(String s) &#123; try &#123; return encodeToByte(s.getBytes(&quot;UTF_8&quot;), false); &#125; catch (UnsupportedEncodingException ignore) &#123; return new byte[]&#123;&#125;; &#125; &#125; public final static byte[] encodeToByte(String s, boolean lineSep) &#123; try &#123; return encodeToByte(s.getBytes(&quot;UTF_8&quot;), lineSep); &#125; catch (UnsupportedEncodingException ignore) &#123; return new byte[]&#123;&#125;; &#125; &#125; public final static byte[] encodeToByte(byte[] arr) &#123; return encodeToByte(arr, false); &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;char[]&lt;/code&gt;. * * @param lineSep optional CRLF after 76 chars, unless EOF. */ public final static byte[] encodeToByte(byte[] arr, boolean lineSep) &#123; int len = arr != null ? arr.length : 0; if (len == 0) &#123; return new byte[0]; &#125; int evenlen = (len / 3) * 3; int cnt = ((len - 1) / 3 + 1) &lt;&lt; 2; int destlen = cnt + (lineSep ? (cnt - 1) / 76 &lt;&lt; 1 : 0); byte[] dest = new byte[destlen]; for (int s = 0, d = 0, cc = 0; s &lt; evenlen; ) &#123; int i = (arr[s++] &amp; 0xff) &lt;&lt; 16 | (arr[s++] &amp; 0xff) &lt;&lt; 8 | (arr[s++] &amp; 0xff); dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 18) &amp; 0x3f]; dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 12) &amp; 0x3f]; dest[d++] = (byte) CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[d++] = (byte) CHARS[i &amp; 0x3f]; if (lineSep &amp;&amp; ++cc == 19 &amp;&amp; d &lt; destlen - 2) &#123; dest[d++] = &apos;\r&apos;; dest[d++] = &apos;\n&apos;; cc = 0; &#125; &#125; int left = len - evenlen; if (left &gt; 0) &#123; int i = ((arr[evenlen] &amp; 0xff) &lt;&lt; 10) | (left == 2 ? ((arr[len - 1] &amp; 0xff) &lt;&lt; 2) : 0); dest[destlen - 4] = (byte) CHARS[i &gt;&gt; 12]; dest[destlen - 3] = (byte) CHARS[(i &gt;&gt;&gt; 6) &amp; 0x3f]; dest[destlen - 2] = left == 2 ? (byte) CHARS[i &amp; 0x3f] : (byte) &apos;=&apos;; dest[destlen - 1] = &apos;=&apos;; &#125; return dest; &#125; public final static String decodeToString(byte[] arr) &#123; try &#123; return new String(decode(arr), &quot;UTF_8&quot;); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; /** * Decodes BASE64 encoded byte array. */ public final static byte[] decode(byte[] arr) &#123; int length = arr.length; if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = arr[endx] == &apos;=&apos; ? (arr[endx - 1] == &apos;=&apos; ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (arr[76] == &apos;\r&apos; ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[arr[sndx++]] &lt;&lt; 18 | INV[arr[sndx++]] &lt;&lt; 12 | INV[arr[sndx++]] &lt;&lt; 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[arr[sndx++]] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125; public final static String encodeToString(String s) &#123; try &#123; return new String(encodeToChar(s.getBytes(&quot;UTF_8&quot;), false)); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; public final static String encodeToString(String s, boolean lineSep) &#123; try &#123; return new String(encodeToChar(s.getBytes(&quot;UTF_8&quot;), lineSep)); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; public final static String encodeToString(byte[] arr) &#123; return new String(encodeToChar(arr, false)); &#125; /** * Encodes a raw byte array into a BASE64 &lt;code&gt;String&lt;/code&gt;. */ public final static String encodeToString(byte[] arr, boolean lineSep) &#123; return new String(encodeToChar(arr, lineSep)); &#125; public final static String decodeToString(String s) &#123; try &#123; return new String(decode(s), &quot;UTF_8&quot;); &#125; catch (UnsupportedEncodingException ignore) &#123; return null; &#125; &#125; /** * Decodes a BASE64 encoded string. */ public final static byte[] decode(String s) &#123; int length = s.length(); if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = s.charAt(endx) == &apos;=&apos; ? (s.charAt(endx - 1) == &apos;=&apos; ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (s.charAt(76) == &apos;\r&apos; ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[s.charAt(sndx++)] &lt;&lt; 18 | INV[s.charAt(sndx++)] &lt;&lt; 12 | INV[s.charAt(sndx++)] &lt;&lt; 6 | INV[s.charAt(sndx++)]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[s.charAt(sndx++)] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125; /** * Decodes a BASE64 encoded char array. */ public final byte[] decode(char[] arr) &#123; int length = arr.length; if (length == 0) &#123; return new byte[0]; &#125; int sndx = 0, endx = length - 1; int pad = arr[endx] == &apos;=&apos; ? (arr[endx - 1] == &apos;=&apos; ? 2 : 1) : 0; int cnt = endx - sndx + 1; int sepCnt = length &gt; 76 ? (arr[76] == &apos;\r&apos; ? cnt / 78 : 0) &lt;&lt; 1 : 0; int len = ((cnt - sepCnt) * 6 &gt;&gt; 3) - pad; byte[] dest = new byte[len]; int d = 0; for (int cc = 0, eLen = (len / 3) * 3; d &lt; eLen; ) &#123; int i = INV[arr[sndx++]] &lt;&lt; 18 | INV[arr[sndx++]] &lt;&lt; 12 | INV[arr[sndx++]] &lt;&lt; 6 | INV[arr[sndx++]]; dest[d++] = (byte) (i &gt;&gt; 16); dest[d++] = (byte) (i &gt;&gt; 8); dest[d++] = (byte) i; if (sepCnt &gt; 0 &amp;&amp; ++cc == 19) &#123; sndx += 2; cc = 0; &#125; &#125; if (d &lt; len) &#123; int i = 0; for (int j = 0; sndx &lt;= endx - pad; j++) &#123; i |= INV[arr[sndx++]] &lt;&lt; (18 - j * 6); &#125; for (int r = 16; d &lt; len; r -= 8) &#123; dest[d++] = (byte) (i &gt;&gt; r); &#125; &#125; return dest; &#125;&#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java加密 AES DES Base32 Base64</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java时间工具类]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E6%97%B6%E9%97%B4%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java时间工具类工具中提供获取当前年、月、日、String类型时间、Long当前毫秒数、日期格式化、根据string类型时间获取Long时间、根据Long类型时间获取当前String时间、获得当天某个时间的毫秒数等。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146package com.common.utils.date;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Calendar;import java.util.Date;/** * * 用于处理时间的工具类 * @author wangming * */public class DateUtil &#123; /** * 获取当前年 * @return String */ public static int getCurrentYear()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.YEAR); &#125; /** * 获取当前月 * @return String */ public static int getCurrentMonth()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.MONTH)+1; &#125; /** * 获取当前日 * @return String */ public static int getCurrentDate()&#123; Calendar cl = Calendar.getInstance(); return cl.get(Calendar.DATE); &#125; /** * 获取当前时分秒 * @return String */ public static String getCurrentTime()&#123; Calendar cl = Calendar.getInstance(); String hour = String.valueOf(cl.get(Calendar.HOUR_OF_DAY)); String minute = String.valueOf(cl.get(Calendar.MINUTE)); String second = String.valueOf(cl.get(Calendar.SECOND)); return hour+&quot;:&quot;+minute+&quot;:&quot;+second; &#125; /** * 获取当前毫秒数 * @return Long */ public static Long getCurrentDateTimeLong()&#123; Calendar cl = Calendar.getInstance(); Long time = cl.getTimeInMillis(); return time; &#125; /** * 获取当前时间 *@param format 要格式化的类型，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd *@return string类型时间 */ public static String getCurrentDateString(String format)&#123; Calendar cl = Calendar.getInstance(); Long time = cl.getTimeInMillis(); SimpleDateFormat sdf= new SimpleDateFormat(format); String dataString = sdf.format(time); return dataString; &#125; /** * 根据string类型时间获取Long时间 * @param date类型时间 * @param format 时间类型格式，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd * @return Long类型时间 */ public static Long getAssignLongTime(String date,String format) &#123; SimpleDateFormat sdf= new SimpleDateFormat(format); Date da = null; try &#123; da = sdf.parse(date); &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; return da.getTime(); &#125; /** * 根据Long类型时间获取当前String时间 * @param date类型时间 * @param format 要返回 时间类型格式，如yyyy-MM-dd HH:mm:ss---yyyy-MM-dd * @return String类型时间 */ public static String getAssignStringTime(Long time,String format) &#123; Date date = new Date(time); SimpleDateFormat sdf= new SimpleDateFormat(format); return sdf.format(date); &#125; /** * 获取昨天的日期 */ public static String getAccountDate()&#123; Date date = new Date(); Calendar c = Calendar.getInstance(); c.setTime(date); c.add(Calendar.DATE,-1); date = c.getTime(); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); String datestr = sdf.format(date); return datestr; &#125; /** * 获得当天某个时间的毫秒数 * @param hour 小时 * @param second 分钟 * @param minute 秒数 * @param millisecode 毫秒 */ public static long getTimesmorning(int hour,int second,int minute,int millisecode)&#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.HOUR_OF_DAY, hour);//获取小时 cal.set(Calendar.SECOND, second);//获取分钟 cal.set(Calendar.MINUTE, minute);//获取秒 cal.set(Calendar.MILLISECOND, millisecode);//获取毫秒 return cal.getTimeInMillis(); &#125; /** * 获得本月最后一天24点时间 */ public static long getTimesMonthnight()&#123; Calendar cal = Calendar.getInstance(); cal.set(cal.get(Calendar.YEAR),cal.get(Calendar.MONDAY), cal.get(Calendar.DAY_OF_MONTH), 0, 0,0); cal.set(Calendar.DAY_OF_MONTH,cal.getActualMaximum(Calendar.DAY_OF_MONTH)); cal.set(Calendar.HOUR_OF_DAY, 24); return cal.getTimeInMillis(); &#125; &#125;]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>java时间处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[java多线程Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 线程生命周期1.新建状态（New）：新创建了一个线程对象。2.就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。3.运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。4.阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：4.1 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。4.2 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。4.3 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。5.死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 线程的优先级每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。 创建线程通过实现 Runnable接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.thread;/** * 输出ABCABCABCABCABCABCABCABCABCABC * @author ming * */class RunnableDemo implements Runnable&#123; private String name; private Object prev; private Object self; private RunnableDemo(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) throws Exception &#123; Object a = new Object(); Object b = new Object(); Object c = new Object(); RunnableDemo pa = new RunnableDemo(&quot;A&quot;, c, a); RunnableDemo pb = new RunnableDemo(&quot;B&quot;, a, b); RunnableDemo pc = new RunnableDemo(&quot;C&quot;, b, c); new Thread(pa).start(); Thread.sleep(100); new Thread(pb).start(); Thread.sleep(100); new Thread(pc).start(); Thread.sleep(100); &#125; &#125; 通过继承 Thread类本身12345678910111213141516171819202122232425262728293031323334353637package com.thread;class Thread1 extends Thread&#123; private String name; public Thread1(String name) &#123; this.name = name; &#125; public void run() &#123; for(int i=0; i&lt;5; i++) &#123; System.out.println(name+i); try &#123; sleep((int)Math.random()*10); &#125;catch(InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ExtendsTreadDemo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName()+&quot;主线程运行开始!&quot;); Thread1 thread1 = new Thread1(&quot;A&quot;); Thread1 thread2 = new Thread1(&quot;B&quot;); thread1.start(); try &#123; thread1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.start(); try &#123; thread2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+ &quot;主线程运行结束!&quot;); &#125;&#125; 通过 Callable和 Future创建线程12345678910111213141516171819202122232425262728293031323334353637383940package com.thread;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class CallableThreadDemo implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadDemo ctt = new CallableThreadDemo(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 10;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i); if(i==5) &#123; new Thread(ft,&quot;有返回值的线程&quot;).start(); &#125; &#125; try &#123; System.out.println(&quot;子线程的返回值：&quot;+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;10;i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;call:&quot;+i); &#125; return i; &#125; &#125; 同步代码块与同步方法这两个方法用的是一把锁，同步方法直接在方法上加synchronized实现加锁，同步代码块则在方法内部加锁，很明显，同步方法锁的范围比较大，而同步代码块范围要小点，一般同步的范围越大，性能就越差，一般需要加锁进行同步的时候，肯定是范围越小越好，这样性能更好。123456789101112131415161718192021222324package com.thread;public class SynchronizedDemo &#123; public synchronized void test1() &#123; for(int i= 0;i&lt;5 ; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; public void test2() &#123; synchronized (this) &#123; for(int i= 0;i&lt;5 ; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo sd = new SynchronizedDemo(); Thread t1 = new Thread(new Runnable() &#123;public void run() &#123;sd.test1();&#125;&#125;); Thread t2 = new Thread(new Runnable() &#123;public void run() &#123;sd.test2();&#125;&#125;); t1.start(); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程 java多线程 同步方法与同步代码快</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java回调函数]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[java回调函数简单来说，就是客户端调用服务起执行一个函数，当服务器端执行完成之后反过来调用客户端的函数，比如ajax进行异步调用。 简单示例 Student.java12345678package com.callback;public class Student &#123; public void doHomework() &#123; System.out.println(&quot;完成作业！&quot;); Teacher teac = new Teacher(); teac.back(); &#125;&#125; Teacher.java1234567891011package com.callback;public class Teacher &#123; public static void main(String[] args) &#123; Student stu = new Student(); stu.doHomework(); &#125; public void back() &#123; System.out.println(&quot;老师我作业完成了！&quot;); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>回调函数 java回调函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2019%2F01%2F21%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[什么是反射？Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。 反射作用？我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等； 实现示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.reflect;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 反射的应用场合：在编译时根本无法知道该对象或类可能属于哪些类， * 程序只依靠运行时信息来发现该对象和类的真实信息. * @author wangming * */public class Person &#123; //私有属性 private String name = &quot;test&quot;; //公有属性 public int age = 20; //公有属性 public int sax = 1; //构造方法 public Person() &#123;&#125; //私有方法 private void say() &#123; System.out.println(&quot;this is private method!&quot;); &#125; //共有方法 public void work() &#123; System.out.println(&quot;this is public method!&quot;); &#125; public static void main(String[] args) &#123; try &#123; //通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object //类型的对象，而我不知道你具体是什么类，用这种方法 /* * Person person = new Person(); Class c1 = person.getClass(); */ //直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高 //这说明任何一个类都有一个隐含的静态成员变量 class Class c2 = Person.class; //通过 Class 对象的 forName() 静态方法来获取，用的最多， //但可能抛出 ClassNotFoundException 异常 /* * try &#123; Class c3 = Class.forName(&quot;com.reflect.Person&quot;); &#125; catch * (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; */ //获得类完整的名字 // String className = c2.getName(); // System.out.println(&quot;className:&quot;+className); //获得类的public类型的属性 // Field[] fields = c2.getFields(); // for(Field field:fields) &#123; // System.out.println(field.getName()); // &#125; //获得类的所有属性。包括私有的 // Field[] AllFields = c2.getDeclaredFields(); // for(Field field:AllFields) &#123; // System.out.println(field.getName()); // &#125; //获得类的public类型的方法。这里包括 Object 类的一些方法 // Method[] methods = c2.getMethods(); // for(Method method:methods) &#123; // System.out.println(method.getName()); // &#125; //获得类的所有方法 // Method[] allMethods = c2.getDeclaredMethods(); // for(Method method:allMethods) &#123; // System.out.println(method.getName()); // &#125; //获得指定的属性// Field f1 = c2.getField(&quot;age&quot;);// System.out.println(f1); //获得指定的私有属性 Field f2 = c2.getDeclaredField(&quot;name&quot;); System.out.println(f2); //创建这个类的一个对象 Object p2 = c2.newInstance(); //将 p2 对象的 f2 属性赋值为 Bob，f2 属性即为 私有属性 name f2.set(p2, &quot;test&quot;); //使用反射机制可以打破封装性，导致了java对象的属性不安全 System.out.println(f2.get(p2)); //获取构造方法 Constructor[] constructors = c2.getConstructors(); for(Constructor constructor:constructors) &#123; System.out.println(constructor.getName()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 原始链接https://www.cnblogs.com/ysocean/p/6516248.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>反射 java反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis使用]]></title>
    <url>%2F2019%2F01%2F20%2Fredis%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[环境jdk1.8、redis数据库commons-pool2-2.6.0.jarjedis-2.9.0.jarcommons-logging-1.0.4.jarlog4j-1.2.16.jar 代码 1.com.redis.RedisUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.redis;import java.io.IOException;import java.io.InputStream;import java.util.Properties;import org.apache.log4j.Logger;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;/** * log4j(commons-logging/log4j) * redis(jedis/commons-pool2) * @author wangming * */public class RedisUtil &#123; private static JedisPool pool=null; //最大连接数 private static int max_active=50; //最大空闲数 private static int max_idle=40; //等待时间 private static long max_waitmillis=3000; //redis主机地址 private static String host; //redis端口 private static int port; //redis用户密码 private static String password; //过期时间 private static int expireTime = 2*60*60*1000; static Logger logger = Logger.getLogger(RedisUtil.class); static&#123; try &#123; //获取配置文件内容 InputStream in = RedisUtil.class.getResourceAsStream(&quot;redis.properties&quot;); Properties prop = new Properties(); prop.load(in); RedisUtil.max_active = Integer.parseInt(prop.getProperty(&quot;max_active&quot;)); RedisUtil.max_idle = Integer.parseInt(prop.getProperty(&quot;max_idle&quot;)); RedisUtil.max_waitmillis = Long.parseLong(prop.getProperty(&quot;max_waitmillis&quot;).toString()); RedisUtil.host = prop.getProperty(&quot;host&quot;); RedisUtil.port = Integer.parseInt(prop.getProperty(&quot;port&quot;)); RedisUtil.password = prop.getProperty(&quot;password&quot;); //初始化连接池 RedisUtil.pool = initPool(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /*** * 初始化连接池 * @return */ private static JedisPool initPool()&#123; JedisPool result = null; try &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxIdle(max_idle); config.setMaxWaitMillis(max_waitmillis); config.setTestOnBorrow(true); if(RedisUtil.password==null||&quot;&quot;.equals(RedisUtil.password))&#123; result = new JedisPool(config,host,port); &#125;else&#123; result = new JedisPool(config,host,port,3000,RedisUtil.password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 向redis添加String，成功返回0，失败返回1 * @param String */ public static int set(String key,String value)&#123; if(value==null || key==null)&#123; logger.debug(&quot;redis存储对象时传入参数为空&quot;); return 1; &#125; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); jedis.set(key, value); &#125;catch(Exception e)&#123; logger.debug(&quot;对象存储redis失败&quot;); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /** * redis数据库查询 */ public static String get(String key)&#123; if(key==null)&#123; logger.debug(&quot;redis查询方法，传入参数为空&quot;); return null; &#125; String result=&quot;&quot;; Jedis jedis=null; try&#123; jedis = RedisUtil.getJedis(); result = jedis.get(key); &#125;catch(Exception e)&#123; logger.debug(&quot;redis查询方法执行失败&quot;+e); &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return result; &#125; /** * 封装jedis的hset方法解释如下 * @param key * @param field 实体类的类名 * @param value 对应分项内容的json串 * @return */ public static long hset(String key,String field,String value)&#123; long result =0; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hset(key, field, value); //设置两小时过期 jedis.expire(key,expireTime); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 封装redis的hget方法,，解释如下 * @param key * @param field 对应实体类的类名 * @return result 对应分项内容的json串 */ public static String hget(String key,String field)&#123; String result =null; Jedis jedis = null; try &#123; jedis = RedisUtil.getJedis(); result = jedis.hget(key, field); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; closeJedis(jedis); &#125; return result; &#125; /** * 设置过期时间 * @param value 秒 * @return 成功返回0，失败返回1 */ public static int expire(String key,int value)&#123; if(key==null)&#123; logger.debug(&quot;redis设置失效时间，传入key参数为空&quot;); return 1; &#125; Jedis jedis =null; try&#123; jedis = RedisUtil.getJedis(); jedis.expire(key, value); &#125;catch(Exception e)&#123; logger.debug(&quot;redis设置&quot;+key+&quot;失效时间失败&quot;); return 1; &#125;finally&#123; RedisUtil.closeJedis(jedis); &#125; return 0; &#125; /*** * 获取Jedis实例 * @return Jedis实例 */ public static Jedis getJedis()&#123; Jedis result = null; try &#123; result = RedisUtil.pool.getResource(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125; /*** * 关闭 Jedis * @param jedis */ public static void closeJedis(Jedis jedis)&#123; if(jedis!=null)&#123; jedis.close(); &#125; &#125; public static void main(String[] args) &#123;// Jedis jedis = getJedis(); String openid = &quot;o5lHPww7MK_ca1-LFLzWUjTRJ7oU&quot;; RedisUtil.set(openid, &quot;20180920/1537413108683.jpg|20180920/1537413108633.jpg|&quot;); String str = RedisUtil.get(openid); //RedisUtil.expire(RedisKeys.PERSONALINCOMETAX, 10*60*60*1000); System.out.println(str); String[] strs = str.split(&quot;\\|&quot;); System.out.println(strs[0]); /*int i = RedisUtil.expire(RedisKeys.IMAGEACQUISITION, 0); System.out.println(i);*/ &#125;&#125;2.com.redis下配置文件redis.properties1234567891011max_active=100#\u6700\u5927\u7a7a\u95f2\u6570max_idle=40#\u6700\u5927\u7b49\u5f85\u65f6\u95f4max_waitmillis=3000#redis\u5730\u5740host=127.0.0.1#redis\u7aef\u53e3port=6379#redis\u5bc6\u7801password=xxx3.com.redis下配置文件log4j.properties12345678910# Global logging configurationlog4j.rootLogger=INFO, stdout# My logging configuration...log4j.logger.com.geong=INFO## Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p %d %C: %m%n git克隆地址https://github.com/syxiaowanzi/redis-util.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>redis redis工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo加上评论系统-Valine]]></title>
    <url>%2F2019%2F01%2F20%2FHexo%E5%8A%A0%E4%B8%8A%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F-Valine%2F</url>
    <content type="text"><![CDATA[环境hexo v3.8.0 、NexT.Pisces v6.7.0、leancloud 步骤leadcloud官网注册账号登陆leadcloud官网 注册 创建应用 应用名称可以自定义 获取appid与appkey创建之后进入应用-设置-应用key 进入博客next主题配置文件中修改搜素valine找到一下内容，修改enable，粘贴id、key，重新打包文件valine:&nbsp;&nbsp;&nbsp;&nbsp;enable: true&nbsp;&nbsp;&nbsp;&nbsp;appid:&nbsp;&nbsp;&nbsp;&nbsp;appkey:&nbsp;&nbsp;&nbsp;&nbsp;notify: false&nbsp;&nbsp;&nbsp;&nbsp;verify: false&nbsp;&nbsp;&nbsp;&nbsp;placeholder: 说点什么…&nbsp;&nbsp;&nbsp;&nbsp;avatar: mm&nbsp;&nbsp;&nbsp;&nbsp;guest_info: nick,mail,link&nbsp;&nbsp;&nbsp;&nbsp;pageSize: 10&nbsp;&nbsp;&nbsp;&nbsp;visitor: false&nbsp;&nbsp;&nbsp;&nbsp;comment_count: true 刷新页面评论测试假如第一次不成功，等两分钟后重新测试 假如某一页面不想加评论在顶部添加comments: false，同样适用与标签与分类 参考地址https://blog.csdn.net/blue_zy/article/details/79071414]]></content>
      <categories>
        <category>hexo-next主题优化</category>
      </categories>
      <tags>
        <tag>hexo添加评论 hexo next主题添加评论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet生成图片验证码]]></title>
    <url>%2F2019%2F01%2F19%2Fservlet%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[环境eclipse(2018-12 (4.10.0)),jdk1.8.0_191,tomcat7.0.62代码1.SafeCodeUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.common.utils.safecode;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;/** 生成指定大小的图片验证码，返回 * 并将图片验证码存入session中 * session对象imageCode * @author admin */public class SafeCodeUtil &#123; public static final String RANDOMCODEKEY = &quot;imageCode&quot;;//放到session中的key private Random random = new Random(); //private String randString = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;//随机产生的字符串 private String randString = &quot;23456789ABCDEFGHJKLMNPRSTWXY&quot;;//随机产生的字符串 private int width = 73;//图片宽 private int height = 28;//图片高 private int lineSize = 30;//干扰线数量 private int stringNum = 4;//随机产生字符数量 /* * 获得字体 */ private Font getFont()&#123; return new Font(&quot;Fixedsys&quot;,Font.CENTER_BASELINE,18); &#125; /* * 获得颜色 */ private Color getRandColor(int fc,int bc)&#123; if(fc &gt; 255) &#123; fc = 255; &#125; if(bc &gt; 255) &#123; bc = 255; &#125; int r = fc + random.nextInt(bc-fc-16); int g = fc + random.nextInt(bc-fc-14); int b = fc + random.nextInt(bc-fc-18); return new Color(r,g,b); &#125; /** * 生成随机图片 */ public void getRandcode(HttpServletRequest request, HttpServletResponse response) &#123; HttpSession session = request.getSession(); //BufferedImage类是具有缓冲区的Image类,Image类是用于描述图像信息的类 BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_BGR); Graphics g = image.getGraphics();//产生Image对象的Graphics对象,改对象可以在图像上进行各种绘制操作 g.fillRect(0, 0, width, height); g.setFont(new Font(&quot;Times New Roman&quot;,Font.ROMAN_BASELINE,18)); g.setColor(getRandColor(110, 133)); //绘制干扰线 for(int i=0;i&lt;=lineSize;i++)&#123; drowLine(g); &#125; //绘制随机字符 String randomString = &quot;&quot;; for(int i=1;i&lt;=stringNum;i++)&#123; randomString=drowString(g,randomString,i); &#125; session.removeAttribute(RANDOMCODEKEY); session.setAttribute(RANDOMCODEKEY, randomString); g.dispose(); try &#123; ImageIO.write(image, &quot;JPEG&quot;, response.getOutputStream());//将内存中的图片通过流动形式输出到客户端 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /* * 绘制字符串 */ private String drowString(Graphics g,String randomString,int i)&#123; g.setFont(getFont()); g.setColor(new Color(random.nextInt(101),random.nextInt(111),random.nextInt(121))); String rand = String.valueOf(getRandomString(random.nextInt(randString.length()))); randomString +=rand; g.translate(random.nextInt(3), random.nextInt(3)); g.drawString(rand, 13*i, 16); return randomString; &#125; /* * 绘制干扰线 */ private void drowLine(Graphics g)&#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(13); int yl = random.nextInt(15); g.drawLine(x, y, x+xl, y+yl); &#125; /* * 获取随机的字符 */ public String getRandomString(int num)&#123; return String.valueOf(randString.charAt(num)); &#125;&#125;2.SafeCode.java123456789101112131415161718192021222324package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/**生成验证码**/public class SafeCode extends HttpServlet &#123; private static final long SERIAL_VERSION_UID = 1L; @Override public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;image/jpeg&quot;);// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;3.GenerateImageCode.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.common.utils.safecode;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.common.utils.safecode.SafeCodeUtil;/** * @author wangming * 生成随机验证码 * Servlet implementation class GenerateImageCode */@WebServlet(&quot;/GenerateImageCode&quot;)public class GenerateImageCode extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public GenerateImageCode() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub doPost(request, response); &#125; /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub response.setContentType(&quot;image/jpeg&quot;);// 设置相应类型,告诉浏览器输出的内容为图片 response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);// 设置响应头信息，告诉浏览器不要缓存此内容 response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expire&quot;, 0); SafeCodeUtil randomValidateCode = new SafeCodeUtil(); try &#123; randomValidateCode.getRandcode(request, response);// 输出图片方法 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;4.web.xml内webapps标签添加如下代码12345678&lt;servlet&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;servlet-class&gt;com.common.utils.safecode.GenerateImageCode&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SafeCode&lt;/servlet-name&gt; &lt;url-pattern&gt;/SafeCode&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;访问路径与结果http://localhost:8888/servletImgVerificationr/SafeCode，结果如下：克隆地址:https://github.com/syxiaowanzi/servlet-utils.git]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>验证码 图片验证码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署与上传github]]></title>
    <url>%2F2019%2F01%2F19%2Fhexo%E9%83%A8%E7%BD%B2%E4%B8%8E%E4%B8%8A%E4%BC%A0github%2F</url>
    <content type="text"><![CDATA[环境winds10,github账户 搭建nodejs安装（我的版本v.10.15.0） 安装git与git客户端安装hexo,可以随便选择文件夹npm install -g hexo-cli hexo初始化与启动hexo init //初始化hexo generate //生成静态页面可以简写成 hexo ghexo server //启动可以简写成 hexo s 默认端口4000 访问本地即可看到一个helloworldhttp://localhost:4000 安装部署到github插件依赖，在站点根目录执行npm install hexo-deployer-git –save github上创建空博客创建新的仓库这里注意例如图中syxiaowanzi.github.io中syxiaowanzi必须是拥有者https://syxiaowanzi.github.io 本地hexo关联github上的博客hexo目录下_config.yml文件最下面添加 deploy: &nbsp;&nbsp;&nbsp;&nbsp;type: git &nbsp;&nbsp;&nbsp;&nbsp;repo: https://github.com/syxiaowanzi/syxiaowanzi.github.io.git &nbsp;&nbsp;&nbsp;&nbsp;branch: master 生成rsakeyssh-keygen -t rsa -C &quot;your github email” 默认会在C:\Users\yourPC.rsa生成连个文件id_rsa.pub与id_rsa 打开id_rsa.pub文件复制内容放到我们当前博客的仓库中 本地上传githubhexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g //生成缓存和静态文件hexo d //重新部署到服务器 访问你的github博客即可看到helloworld优化博客我们可以选择多种优化主题，优化菜单等参考链接：https://blog.csdn.net/qq_32454537/article/details/79482896https://www.jianshu.com/p/efbeddc5eb19https://www.jianshu.com/p/56d99a3049a5]]></content>
      <categories>
        <category>hexo部署</category>
      </categories>
      <tags>
        <tag>hexo部署 hexo上传github</tag>
      </tags>
  </entry>
</search>
